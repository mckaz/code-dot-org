Class,Method Name,Arg/Ret/Var,Variable Name,Inferred Type,Original Type,Exact (E) / Up to Parameter (P) / Got Type (T) / None (N),Solution Source,Source Code
[s]Dashboard,admin?,Arg,user_id,Number,Number,E,Heur: int_names,"def self.admin?(user_id)
    !!db[:users][id: user_id, admin: true]
  end"
[s]Dashboard,admin?,Ret,"",(false or true),(false or true),E,Constraints,"def self.admin?(user_id)
    !!db[:users][id: user_id, admin: true]
  end"
[s]Dashboard::User,get_with_deleted,Arg,user_id,Number,Number,E,Heur: int_names,"def self.get_with_deleted(user_id)
      row = Dashboard.db[:users].where(id: user_id).first
      return nil unless row
      Dashboard::User.new(row)
    end"
[s]Dashboard::User,get_with_deleted,Ret,"",Dashboard::User,Dashboard::User,E,Constraints,"def self.get_with_deleted(user_id)
      row = Dashboard.db[:users].where(id: user_id).first
      return nil unless row
      Dashboard::User.new(row)
    end"
[s]Dashboard::User,get,Arg,user_id,Number,Number,E,Heur: int_names,"def self.get(user_id)
      row = Dashboard.db[:users].where(id: user_id, deleted_at: nil).first
      return nil unless row
      Dashboard::User.new(row)
    end"
[s]Dashboard::User,get,Ret,"",Dashboard::User,Dashboard::User,E,Constraints,"def self.get(user_id)
      row = Dashboard.db[:users].where(id: user_id, deleted_at: nil).first
      return nil unless row
      Dashboard::User.new(row)
    end"
Dashboard::User,get_followed_bys,Arg,other_user_ids,Array<Number>,Array<Number>,E,Heur: int_array_name,"def get_followed_bys(other_user_ids)
      Dashboard.db[:sections].
        join(:followers, section_id: :sections__id).
        join(:users, id: :followers__student_user_id).
        where(sections__user_id: id, sections__deleted_at: nil).
        where(followers__student_user_id: other_user_ids, followers__deleted_at: nil).
        where(users__deleted_at: nil).
        select_map(:followers__student_user_id)
    end"
Dashboard::User,get_followed_bys,Ret,"",Array<Number>,Array<Number>,E,Constraints,"def get_followed_bys(other_user_ids)
      Dashboard.db[:sections].
        join(:followers, section_id: :sections__id).
        join(:users, id: :followers__student_user_id).
        where(sections__user_id: id, sections__deleted_at: nil).
        where(followers__student_user_id: other_user_ids, followers__deleted_at: nil).
        where(users__deleted_at: nil).
        select_map(:followers__student_user_id)
    end"
Dashboard::User,followed_by?,Arg,other_user_id,Number,Number,E,Heur: int_names,"def followed_by?(other_user_id)
      Dashboard.db[:sections].
        join(:followers, section_id: :sections__id).
        join(:users, id: :followers__student_user_id).
        where(sections__user_id: id, sections__deleted_at: nil).
        where(followers__student_user_id: other_user_id, followers__deleted_at: nil).
        where(users__deleted_at: nil).
        any?
    end"
Dashboard::User,followed_by?,Ret,"",(false or true),(false or true),E,Constraints,"def followed_by?(other_user_id)
      Dashboard.db[:sections].
        join(:followers, section_id: :sections__id).
        join(:users, id: :followers__student_user_id).
        where(sections__user_id: id, sections__deleted_at: nil).
        where(followers__student_user_id: other_user_id, followers__deleted_at: nil).
        where(users__deleted_at: nil).
        any?
    end"
Dashboard::User,owned_sections,Ret,"",Array<{ id: Number }>,Array<{ id: Number }>,E,Constraints,"def owned_sections
      Dashboard.db[:sections].
        select(:id).where(user_id: id, deleted_at: nil).all
    end"
Dashboard::User,@row,Var,@row,"{ id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }","({ id: Number, email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, language: String, birthday: Date, parent_email: String, deleted_at: (DateTime or Time), hashed_email: String, properties: String, user_type: String, school: String, full_address: String, address: String, city: String, state: String, zip: String, lat: Number, lon: Number, total_lines: Number, secret_words: String, secret_picture_id: Number, secret_word_1_id: Number, secret_word_2_id: Number } or { id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number })",P,Constraints,""
Dashboard::User,admin?,Ret,"",(false or true),(false or true),E,Constraints,"def admin?
      !!@row[:admin]
    end"
Dashboard::User,has_permission?,Arg,permission,(Array<String> or String),String,T,Constraints,"def has_permission?(permission)
      permission = permission.to_s.strip.downcase
      case permission
        when 'admin' then admin?
        when 'teacher' then teacher?
        else !!Dashboard.db[:user_permissions][user_id: id, permission: permission]
      end
    end"
Dashboard::User,has_permission?,Ret,"",(false or true),(false or true),E,Constraints,"def has_permission?(permission)
      permission = permission.to_s.strip.downcase
      case permission
        when 'admin' then admin?
        when 'teacher' then teacher?
        else !!Dashboard.db[:user_permissions][user_id: id, permission: permission]
      end
    end"
Object,teaches_student?,Arg,student_id,Number,Number,E,Heur: int_names,"def teaches_student?(student_id, user_id = current_user_id)
  return false unless student_id && user_id
  DASHBOARD_DB[:sections].
      join(:followers, section_id: :sections__id).
      join(:users, id: :followers__student_user_id).
      where(sections__user_id: user_id, sections__deleted_at: nil).
      where(followers__student_user_id: student_id, followers__deleted_at: nil).
      where(users__deleted_at: nil).
      any?
end"
Object,teaches_student?,Arg,user_id,?Number,?Number,E,Constraints,"def teaches_student?(student_id, user_id = current_user_id)
  return false unless student_id && user_id
  DASHBOARD_DB[:sections].
      join(:followers, section_id: :sections__id).
      join(:users, id: :followers__student_user_id).
      where(sections__user_id: user_id, sections__deleted_at: nil).
      where(followers__student_user_id: student_id, followers__deleted_at: nil).
      where(users__deleted_at: nil).
      any?
end"
Object,teaches_student?,Ret,"",(false or true),(false or true),E,Constraints,"def teaches_student?(student_id, user_id = current_user_id)
  return false unless student_id && user_id
  DASHBOARD_DB[:sections].
      join(:followers, section_id: :sections__id).
      join(:users, id: :followers__student_user_id).
      where(sections__user_id: user_id, sections__deleted_at: nil).
      where(followers__student_user_id: student_id, followers__deleted_at: nil).
      where(users__deleted_at: nil).
      any?
end"
Object,owns_section?,Arg,section_id,Number,Number,E,Heur: int_names,"def owns_section?(section_id)
  return false unless section_id && current_user_id
  DASHBOARD_DB[:sections].where(id: section_id, user_id: current_user_id).any?
end"
Object,owns_section?,Ret,"",(false or true),(false or true),E,Constraints,"def owns_section?(section_id)
  return false unless section_id && current_user_id
  DASHBOARD_DB[:sections].where(id: section_id, user_id: current_user_id).any?
end"
Object,@user_permissions,Var,@user_permissions,Array<String>,Array<String>,E,Constraints,""
Object,has_permission?,Arg,permission,String,String,E,Twin,"def has_permission?(permission)
  return false unless current_user

  if @user_permissions.nil?
    @user_permissions = DASHBOARD_DB[:user_permissions].where(user_id: current_user_id).pluck(:permission)
  end
  @user_permissions.include? permission
end"
Object,has_permission?,Ret,"",(false or true),(false or true),E,Constraints,"def has_permission?(permission)
  return false unless current_user

  if @user_permissions.nil?
    @user_permissions = DASHBOARD_DB[:user_permissions].where(user_id: current_user_id).pluck(:permission)
  end
  @user_permissions.include? permission
end"
Object,@dashboard_user,Var,@dashboard_user,"{ id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }","({ id: Number, email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, language: String, birthday: Date, parent_email: String, deleted_at: (DateTime or Time), hashed_email: String, properties: String, user_type: String, school: String, full_address: String, address: String, city: String, state: String, zip: String, lat: Number, lon: Number, total_lines: Number, secret_words: String, secret_picture_id: Number, secret_word_1_id: Number, secret_word_2_id: Number } or { id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number })",P,Constraints,""
Object,current_user,Ret,"","{ id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }",User,T,Constraints,"def current_user
  nil if current_user_id.nil?
  @dashboard_user ||= DASHBOARD_DB[:users][id: current_user_id]
end"
Object,get_user_sharing_disabled,Arg,user_id,Number,Number,E,Heur: int_names,"def get_user_sharing_disabled(user_id)
  user_properties = DASHBOARD_DB[:users].select(:properties).first(id: user_id)
  return false unless user_properties
  get_sharing_disabled_from_properties(user_properties[:properties])
end"
Object,get_user_sharing_disabled,Ret,"",(false or true),(false or true),E,Constraints,"def get_user_sharing_disabled(user_id)
  user_properties = DASHBOARD_DB[:users].select(:properties).first(id: user_id)
  return false unless user_properties
  get_sharing_disabled_from_properties(user_properties[:properties])
end"
[s]DashboardStudent,fetch_user_students,Arg,user_id,Number,Number,E,Heur: int_names,"def self.fetch_user_students(user_id)
    Dashboard.db[:sections].
      join(:followers, section_id: :sections__id).
      join(:users, id: :followers__student_user_id).
      where(sections__user_id: user_id, sections__deleted_at: nil).
      where(followers__deleted_at: nil).
      where(users__deleted_at: nil).
      select(*fields).
      all
  end"
[s]DashboardStudent,fetch_user_students,Ret,"","Array<{ id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true), student_user_id: Number, section_id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }>","Array<{ gender: String, user_type: String, hashed_email: String, secret_words: String, total_lines: Number, birthday: Date, email: String, username: String, name: String, id: Number }>",P,Constraints,"def self.fetch_user_students(user_id)
    Dashboard.db[:sections].
      join(:followers, section_id: :sections__id).
      join(:users, id: :followers__student_user_id).
      where(sections__user_id: user_id, sections__deleted_at: nil).
      where(followers__deleted_at: nil).
      where(users__deleted_at: nil).
      select(*fields).
      all
  end"
[s]DashboardStudent,fields,Ret,"","[:users__id___id, :users__name___name, :users__username___username, :users__email___email, :users__hashed_email___hashed_email, :users__user_type___user_type, :users__gender___gender, :users__birthday___birthday, :users__total_lines___total_lines, :users__secret_words___secret_words]","[:users__id___id, :users__name___name, :users__username___username, :users__email___email, :users__hashed_email___hashed_email, :users__user_type___user_type, :users__gender___gender, :users__birthday___birthday, :users__total_lines___total_lines, :users__secret_words___secret_words]",E,Constraints,"def self.fields
    [
      :users__id___id,
      :users__name___name,
      :users__username___username,
      :users__email___email,
      :users__hashed_email___hashed_email,
      :users__user_type___user_type,
      :users__gender___gender,
      :users__birthday___birthday,
      :users__total_lines___total_lines,
      :users__secret_words___secret_words
    ]
  end"
[s]DashboardSection,fields,Ret,"","[:sections__id___id, :sections__name___name, :sections__code___code, :sections__stage_extras___stage_extras, :sections__pairing_allowed___pairing_allowed, :sections__login_type___login_type, :sections__sharing_disabled___sharing_disabled, :sections__hidden___hidden, :sections__grade___grade, :sections__script_id___script_id, :sections__course_id___course_id, :sections__user_id___teacher_id]","[:sections__id___id, :sections__name___name, :sections__code___code, :sections__stage_extras___stage_extras, :sections__pairing_allowed___pairing_allowed, :sections__login_type___login_type, :sections__sharing_disabled___sharing_disabled, :sections__hidden___hidden, :sections__grade___grade, :sections__script_id___script_id, :sections__course_id___course_id, :sections__user_id___teacher_id]",E,Constraints,"def self.fields
    [
      :sections__id___id,
      :sections__name___name,
      :sections__code___code,
      :sections__stage_extras___stage_extras,
      :sections__pairing_allowed___pairing_allowed,
      :sections__login_type___login_type,
      :sections__sharing_disabled___sharing_disabled,
      :sections__hidden___hidden,
      :sections__grade___grade,
      :sections__script_id___script_id,
      :sections__course_id___course_id,
      :sections__user_id___teacher_id
    ]
  end"
[s]DashboardStudent,random_secrets,Ret,"","Hash<Symbol, ({ [s]DashboardStudent#random_secret_picture_id ret: ret } or { [s]DashboardStudent#random_secret_words ret: ret })>","{ secret_picture_id: Number, secret_words: String }",P,Constraints,"def self.random_secrets
    {
      secret_picture_id: random_secret_picture_id,
      secret_words: random_secret_words
    }
  end"
[s]DashboardStudent,fetch_if_allowed,Arg,id,Number,Number,E,Constraints,"def self.fetch_if_allowed(id, dashboard_user_id)
    user = Dashboard::User.get(dashboard_user_id)
    return unless user && (user.followed_by?(id) || user.admin?)

    row = Dashboard.db[:users].
      where(users__id: id, users__deleted_at: nil).
      left_outer_join(:secret_pictures, id: :secret_picture_id).
      select(*fields,
        :secret_pictures__name___secret_picture_name,
        :secret_pictures__path___secret_picture_path,
      ).
      server(:default).
      first

    return if row.nil?

    row.merge(age: birthday_to_age(row[:birthday]))
  end"
[s]DashboardStudent,fetch_if_allowed,Arg,dashboard_user_id,Number,Number,E,Constraints,"def self.fetch_if_allowed(id, dashboard_user_id)
    user = Dashboard::User.get(dashboard_user_id)
    return unless user && (user.followed_by?(id) || user.admin?)

    row = Dashboard.db[:users].
      where(users__id: id, users__deleted_at: nil).
      left_outer_join(:secret_pictures, id: :secret_picture_id).
      select(*fields,
        :secret_pictures__name___secret_picture_name,
        :secret_pictures__path___secret_picture_path,
      ).
      server(:default).
      first

    return if row.nil?

    row.merge(age: birthday_to_age(row[:birthday]))
  end"
[s]DashboardStudent,fetch_if_allowed,Ret,"","{ id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number, path: String, age: { [s]DashboardStudent#birthday_to_age ret: ret } }","{ id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number, path: String, age: (Number or String) }",P,Constraints,"def self.fetch_if_allowed(id, dashboard_user_id)
    user = Dashboard::User.get(dashboard_user_id)
    return unless user && (user.followed_by?(id) || user.admin?)

    row = Dashboard.db[:users].
      where(users__id: id, users__deleted_at: nil).
      left_outer_join(:secret_pictures, id: :secret_picture_id).
      select(*fields,
        :secret_pictures__name___secret_picture_name,
        :secret_pictures__path___secret_picture_path,
      ).
      server(:default).
      first

    return if row.nil?

    row.merge(age: birthday_to_age(row[:birthday]))
  end"
[s]DashboardStudent,random_secret_picture_id,Ret,"",%any,Number,T,Constraints,"def self.random_secret_picture_id
    SecureRandom.random_number(Dashboard.db[:secret_pictures].count) + 1
  end"
[s]DashboardStudent,update_if_allowed,Arg,params,"{ id: (Array<Number> or Number), name: [ nil_or_empty?: () -> { { { [s]DashboardStudent#update_if_allowed arg: params }#[] call_ret: ret }#nil_or_empty? call_ret: ret } ], password: [ nil_or_empty?: () -> { { { [s]DashboardStudent#update_if_allowed arg: params }#[] call_ret: ret }#nil_or_empty? call_ret: ret } ], gender: { { [s]DashboardStudent#update_if_allowed arg: params }#[] call_ret: ret }, age: ([ *: (Number) -> { { [s]DashboardStudent#age_to_birthday arg: age }#* call_ret: ret } ] and [ ==: (Number) -> (false or true) ] and [ to_i: () -> Number ]), secrets: [ to_s: () -> String ] }","{ id: Number, name: String, age: Number, password: String, gender: String, secrets: String }",P,Heur: hash_access,"def self.update_if_allowed(params, dashboard_user_id)
    user_to_update = Dashboard.db[:users].where(id: params[:id], deleted_at: nil)
    return if user_to_update.empty?
    return if Dashboard.db[:sections].
      join(:followers, section_id: :sections__id).
      where(sections__user_id: dashboard_user_id, sections__deleted_at: nil).
      where(followers__student_user_id: params[:id], followers__deleted_at: nil).
      empty?

    fields = {updated_at: DateTime.now}
    fields[:name] = params[:name] unless params[:name].nil_or_empty?
    fields[:encrypted_password] = encrypt_password(params[:password]) unless params[:password].nil_or_empty?
    fields[:gender] = params[:gender] if valid_gender?(params[:gender])
    fields[:birthday] = age_to_birthday(params[:age]) if age_to_birthday(params[:age])
    # TODO: Only save birthday if age changed.
    fields.merge!(random_secrets) if params[:secrets].to_s == 'reset'

    rows_updated = user_to_update.update(fields)
    return nil unless rows_updated > 0

    fetch_if_allowed(params[:id], dashboard_user_id)
  end"
[s]DashboardStudent,update_if_allowed,Arg,dashboard_user_id,Number,Number,E,Constraints,"def self.update_if_allowed(params, dashboard_user_id)
    user_to_update = Dashboard.db[:users].where(id: params[:id], deleted_at: nil)
    return if user_to_update.empty?
    return if Dashboard.db[:sections].
      join(:followers, section_id: :sections__id).
      where(sections__user_id: dashboard_user_id, sections__deleted_at: nil).
      where(followers__student_user_id: params[:id], followers__deleted_at: nil).
      empty?

    fields = {updated_at: DateTime.now}
    fields[:name] = params[:name] unless params[:name].nil_or_empty?
    fields[:encrypted_password] = encrypt_password(params[:password]) unless params[:password].nil_or_empty?
    fields[:gender] = params[:gender] if valid_gender?(params[:gender])
    fields[:birthday] = age_to_birthday(params[:age]) if age_to_birthday(params[:age])
    # TODO: Only save birthday if age changed.
    fields.merge!(random_secrets) if params[:secrets].to_s == 'reset'

    rows_updated = user_to_update.update(fields)
    return nil unless rows_updated > 0

    fetch_if_allowed(params[:id], dashboard_user_id)
  end"
[s]DashboardStudent,update_if_allowed,Ret,"","{ id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number, path: String, age: { [s]DashboardStudent#birthday_to_age ret: ret } }","{ id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number, path: String, age: (Number or String) }",P,Constraints,"def self.update_if_allowed(params, dashboard_user_id)
    user_to_update = Dashboard.db[:users].where(id: params[:id], deleted_at: nil)
    return if user_to_update.empty?
    return if Dashboard.db[:sections].
      join(:followers, section_id: :sections__id).
      where(sections__user_id: dashboard_user_id, sections__deleted_at: nil).
      where(followers__student_user_id: params[:id], followers__deleted_at: nil).
      empty?

    fields = {updated_at: DateTime.now}
    fields[:name] = params[:name] unless params[:name].nil_or_empty?
    fields[:encrypted_password] = encrypt_password(params[:password]) unless params[:password].nil_or_empty?
    fields[:gender] = params[:gender] if valid_gender?(params[:gender])
    fields[:birthday] = age_to_birthday(params[:age]) if age_to_birthday(params[:age])
    # TODO: Only save birthday if age changed.
    fields.merge!(random_secrets) if params[:secrets].to_s == 'reset'

    rows_updated = user_to_update.update(fields)
    return nil unless rows_updated > 0

    fetch_if_allowed(params[:id], dashboard_user_id)
  end"
[s]DashboardSection,update_if_owner,Arg,params,"{ id: (Array<Number> or Number), user: { { [s]DashboardSection#update_if_owner arg: params }#[] call_ret: ret }, name: [ nil_or_empty?: () -> { { { [s]DashboardSection#update_if_owner arg: params }#[] call_ret: ret }#nil_or_empty? call_ret: ret } ], login_type: { { [s]DashboardSection#update_if_owner arg: params }#[] call_ret: ret }, grade: { { [s]DashboardSection#update_if_owner arg: params }#[] call_ret: ret }, stage_extras: (false or true), pairing_allowed: (false or true), hidden: [ nil?: () -> { { { [s]DashboardSection#update_if_owner arg: params }#[] call_ret: ret }#nil? call_ret: ret } ], course_id: { { [s]DashboardSection#update_if_owner arg: params }#[] call_ret: ret }, script: { { [s]DashboardSection#update_if_owner arg: params }#[] call_ret: ret }, script_id: [ !: () -> { { { [s]DashboardSection#update_if_owner arg: params }#[] call_ret: ret }#! call_ret: ret } ] }","{ id: Number, user: ({ id: Number, email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, language: String, birthday: Date, parent_email: String, deleted_at: (DateTime or Time), hashed_email: String, properties: String, user_type: String, school: String, full_address: String, address: String, city: String, state: String, zip: String, lat: Number, lon: Number, total_lines: Number, secret_words: String, secret_picture_id: Number, secret_word_1_id: Number, secret_word_2_id: Number } or { id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }), name: String, login_type: String, stage_extras: (false or true), hidden: (false or true), course_id: Number, script: { id: Number }, grade: String, pairing_allowed: (false or true) }",P,Heur: hash_access,"def self.update_if_owner(params)
    section_id = params[:id]
    return nil unless params[:user] && params[:user][:user_type] == 'teacher'
    user_id = params[:user][:id]

    fields = {updated_at: DateTime.now}
    fields[:name] = params[:name] unless params[:name].nil_or_empty?
    fields[:login_type] = params[:login_type] if valid_login_type?(params[:login_type])
    fields[:grade] = params[:grade] if valid_grade?(params[:grade])
    fields[:stage_extras] = params[:stage_extras]
    fields[:pairing_allowed] = params[:pairing_allowed]
    fields[:hidden] = params[:hidden] unless params[:hidden].nil?

    if params[:course_id] && valid_course_id?(params[:course_id])
      fields[:course_id] = params[:course_id].to_i
      # explicitly clear script_id (unless we're also passed in a valid script id
      # as a param
      fields[:script_id] = nil
    else
      # If no valid course_id provided, make sure we clear any existing course_id
      fields[:course_id] = nil
    end

    if params[:script] && valid_script_id?(params[:script][:id], user_id)
      fields[:script_id] = params[:script][:id].to_i
      DashboardUserScript.assign_script_to_section(fields[:script_id], section_id)
      DashboardUserScript.assign_script_to_user(fields[:script_id], user_id)
    elsif !params[:course_id] && !params[:script_id]
      # If a null course (no choice or decide later) is chosen, then update the course and script to be nil
      fields[:course_id] = nil
      fields[:script_id] = nil
    end

    rows_updated = Dashboard.db[:sections].
      where(id: section_id, user_id: user_id, deleted_at: nil).
      update(fields)
    return nil unless rows_updated > 0

    fetch_if_allowed(section_id, user_id)
  end"
[s]DashboardSection,update_if_owner,Ret,"",DashboardSection,DashboardSection,E,Constraints,"def self.update_if_owner(params)
    section_id = params[:id]
    return nil unless params[:user] && params[:user][:user_type] == 'teacher'
    user_id = params[:user][:id]

    fields = {updated_at: DateTime.now}
    fields[:name] = params[:name] unless params[:name].nil_or_empty?
    fields[:login_type] = params[:login_type] if valid_login_type?(params[:login_type])
    fields[:grade] = params[:grade] if valid_grade?(params[:grade])
    fields[:stage_extras] = params[:stage_extras]
    fields[:pairing_allowed] = params[:pairing_allowed]
    fields[:hidden] = params[:hidden] unless params[:hidden].nil?

    if params[:course_id] && valid_course_id?(params[:course_id])
      fields[:course_id] = params[:course_id].to_i
      # explicitly clear script_id (unless we're also passed in a valid script id
      # as a param
      fields[:script_id] = nil
    else
      # If no valid course_id provided, make sure we clear any existing course_id
      fields[:course_id] = nil
    end

    if params[:script] && valid_script_id?(params[:script][:id], user_id)
      fields[:script_id] = params[:script][:id].to_i
      DashboardUserScript.assign_script_to_section(fields[:script_id], section_id)
      DashboardUserScript.assign_script_to_user(fields[:script_id], user_id)
    elsif !params[:course_id] && !params[:script_id]
      # If a null course (no choice or decide later) is chosen, then update the course and script to be nil
      fields[:course_id] = nil
      fields[:script_id] = nil
    end

    rows_updated = Dashboard.db[:sections].
      where(id: section_id, user_id: user_id, deleted_at: nil).
      update(fields)
    return nil unless rows_updated > 0

    fetch_if_allowed(section_id, user_id)
  end"
[s]DashboardUserScript,assign_script_to_user,Arg,script_id,Number,Number,E,Constraints,"def self.assign_script_to_user(script_id, user_id)
    time_now = Time.now
    existing = Dashboard.db[:user_scripts].where(user_id: user_id, script_id: script_id).first
    if existing
      return if existing[:assigned_at]
      Dashboard.db[:user_scripts].where(user_id: user_id, script_id: script_id).update(
        updated_at: time_now,
        assigned_at: time_now
      )
    else
      Dashboard.db[:user_scripts].insert(
        user_id: user_id,
        script_id: script_id,
        created_at: time_now,
        updated_at: time_now,
        assigned_at: time_now
      )
    end
  end"
[s]DashboardUserScript,assign_script_to_user,Arg,user_id,Number,Number,E,Constraints,"def self.assign_script_to_user(script_id, user_id)
    time_now = Time.now
    existing = Dashboard.db[:user_scripts].where(user_id: user_id, script_id: script_id).first
    if existing
      return if existing[:assigned_at]
      Dashboard.db[:user_scripts].where(user_id: user_id, script_id: script_id).update(
        updated_at: time_now,
        assigned_at: time_now
      )
    else
      Dashboard.db[:user_scripts].insert(
        user_id: user_id,
        script_id: script_id,
        created_at: time_now,
        updated_at: time_now,
        assigned_at: time_now
      )
    end
  end"
[s]DashboardUserScript,assign_script_to_user,Ret,"",Number,Number,E,Constraints,"def self.assign_script_to_user(script_id, user_id)
    time_now = Time.now
    existing = Dashboard.db[:user_scripts].where(user_id: user_id, script_id: script_id).first
    if existing
      return if existing[:assigned_at]
      Dashboard.db[:user_scripts].where(user_id: user_id, script_id: script_id).update(
        updated_at: time_now,
        assigned_at: time_now
      )
    else
      Dashboard.db[:user_scripts].insert(
        user_id: user_id,
        script_id: script_id,
        created_at: time_now,
        updated_at: time_now,
        assigned_at: time_now
      )
    end
  end"
[s]DashboardUserScript,assign_script_to_users,Arg,script_id,Number,Number,E,Heur: int_names,"def self.assign_script_to_users(script_id, user_ids)
    # NOTE: This method could be more simply written by iterating over user_ids, calling
    # DashboardUserScript#assign_script_to_user for each. This (more complex) approach is used for
    # its better DB performance.
    return if user_ids.empty?

    time_now = Time.now
    all_existing = Dashboard.db[:user_scripts].where(user_id: user_ids, script_id: script_id)
    all_existing_user_ids = all_existing.map {|user_script| user_script[:user_id]}

    missing_assigned_at = []
    all_existing.each do |existing|
      missing_assigned_at << existing[:id] unless existing[:assigned_at]
    end
    Dashboard.db[:user_scripts].where(id: missing_assigned_at).update(
      updated_at: time_now,
      assigned_at: time_now
    )
    missing_user_scripts = RDL.type_cast(user_ids.select {|user_id| !all_existing_user_ids.include? user_id}, ""Array<Integer>"")
    return if missing_user_scripts.empty?
    Dashboard.db[:user_scripts].
      import(
        [:user_id, :script_id, :created_at, :updated_at, :assigned_at],
        RDL.type_cast(missing_user_scripts.zip(
          [script_id] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count
      ), ""Array<[Integer, Integer, Time, Time, Time]>"")
      )
  end"
[s]DashboardUserScript,assign_script_to_users,Arg,user_ids,Array<Number>,Array<Number>,E,Heur: int_array_name,"def self.assign_script_to_users(script_id, user_ids)
    # NOTE: This method could be more simply written by iterating over user_ids, calling
    # DashboardUserScript#assign_script_to_user for each. This (more complex) approach is used for
    # its better DB performance.
    return if user_ids.empty?

    time_now = Time.now
    all_existing = Dashboard.db[:user_scripts].where(user_id: user_ids, script_id: script_id)
    all_existing_user_ids = all_existing.map {|user_script| user_script[:user_id]}

    missing_assigned_at = []
    all_existing.each do |existing|
      missing_assigned_at << existing[:id] unless existing[:assigned_at]
    end
    Dashboard.db[:user_scripts].where(id: missing_assigned_at).update(
      updated_at: time_now,
      assigned_at: time_now
    )
    missing_user_scripts = RDL.type_cast(user_ids.select {|user_id| !all_existing_user_ids.include? user_id}, ""Array<Integer>"")
    return if missing_user_scripts.empty?
    Dashboard.db[:user_scripts].
      import(
        [:user_id, :script_id, :created_at, :updated_at, :assigned_at],
        RDL.type_cast(missing_user_scripts.zip(
          [script_id] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count
      ), ""Array<[Integer, Integer, Time, Time, Time]>"")
      )
  end"
[s]DashboardUserScript,assign_script_to_users,Ret,"",Array<String>,Array<String>,E,Constraints,"def self.assign_script_to_users(script_id, user_ids)
    # NOTE: This method could be more simply written by iterating over user_ids, calling
    # DashboardUserScript#assign_script_to_user for each. This (more complex) approach is used for
    # its better DB performance.
    return if user_ids.empty?

    time_now = Time.now
    all_existing = Dashboard.db[:user_scripts].where(user_id: user_ids, script_id: script_id)
    all_existing_user_ids = all_existing.map {|user_script| user_script[:user_id]}

    missing_assigned_at = []
    all_existing.each do |existing|
      missing_assigned_at << existing[:id] unless existing[:assigned_at]
    end
    Dashboard.db[:user_scripts].where(id: missing_assigned_at).update(
      updated_at: time_now,
      assigned_at: time_now
    )
    missing_user_scripts = RDL.type_cast(user_ids.select {|user_id| !all_existing_user_ids.include? user_id}, ""Array<Integer>"")
    return if missing_user_scripts.empty?
    Dashboard.db[:user_scripts].
      import(
        [:user_id, :script_id, :created_at, :updated_at, :assigned_at],
        RDL.type_cast(missing_user_scripts.zip(
          [script_id] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count
      ), ""Array<[Integer, Integer, Time, Time, Time]>"")
      )
  end"
[s]DashboardUserScript,assign_script_to_section,Arg,script_id,Number,Number,E,Constraints,"def self.assign_script_to_section(script_id, section_id)
    student_user_ids = Dashboard.db[:followers].
      select(:student_user_id).
      where(section_id: section_id, deleted_at: nil).
      map {|f| f[:student_user_id]}
    DashboardUserScript.assign_script_to_users(script_id, student_user_ids)
  end"
[s]DashboardUserScript,assign_script_to_section,Arg,section_id,(Array<Number> or Number),Number,T,Constraints,"def self.assign_script_to_section(script_id, section_id)
    student_user_ids = Dashboard.db[:followers].
      select(:student_user_id).
      where(section_id: section_id, deleted_at: nil).
      map {|f| f[:student_user_id]}
    DashboardUserScript.assign_script_to_users(script_id, student_user_ids)
  end"
[s]DashboardUserScript,assign_script_to_section,Ret,"",Array<String>,Array<String>,E,Constraints,"def self.assign_script_to_section(script_id, section_id)
    student_user_ids = Dashboard.db[:followers].
      select(:student_user_id).
      where(section_id: section_id, deleted_at: nil).
      map {|f| f[:student_user_id]}
    DashboardUserScript.assign_script_to_users(script_id, student_user_ids)
  end"
[s]DashboardSection,fetch_if_allowed,Arg,id,(Array<Number> or Number),Number,T,Constraints,"def self.fetch_if_allowed(id, user_id)
    # TODO: Allow caller to specify fields that they want because the
    # joins are getting a bit out of control (eg. you don't want to
    # get all the students passwords when we get the list of sections).

    return nil unless row = Dashboard.db[:sections].
      join(:users, id: :user_id).
      where(sections__id: id, sections__deleted_at: nil).
      select(*fields).
      first

    section = new(row)
    return section if section.member?(user_id) || Dashboard.admin?(user_id)
    nil
  end"
[s]DashboardSection,fetch_if_allowed,Arg,user_id,Number,Number,E,Constraints,"def self.fetch_if_allowed(id, user_id)
    # TODO: Allow caller to specify fields that they want because the
    # joins are getting a bit out of control (eg. you don't want to
    # get all the students passwords when we get the list of sections).

    return nil unless row = Dashboard.db[:sections].
      join(:users, id: :user_id).
      where(sections__id: id, sections__deleted_at: nil).
      select(*fields).
      first

    section = new(row)
    return section if section.member?(user_id) || Dashboard.admin?(user_id)
    nil
  end"
[s]DashboardSection,fetch_if_allowed,Ret,"",DashboardSection,DashboardSection,E,Constraints,"def self.fetch_if_allowed(id, user_id)
    # TODO: Allow caller to specify fields that they want because the
    # joins are getting a bit out of control (eg. you don't want to
    # get all the students passwords when we get the list of sections).

    return nil unless row = Dashboard.db[:sections].
      join(:users, id: :user_id).
      where(sections__id: id, sections__deleted_at: nil).
      select(*fields).
      first

    section = new(row)
    return section if section.member?(user_id) || Dashboard.admin?(user_id)
    nil
  end"
[s]DashboardSection,fetch_student_sections,Arg,student_id,Number,Number,E,Heur: int_names,"def self.fetch_student_sections(student_id)
    return if student_id.nil?

    Dashboard.db[:sections].
      select(*fields).
      join(:followers, section_id: :id).
      join(:users, id: :student_user_id).
      where(student_user_id: student_id).
      where(sections__deleted_at: nil, followers__deleted_at: nil).
      map {|row| new(row).to_member_hash}
  end"
[s]DashboardSection,fetch_student_sections,Ret,"","Array<{ id: { { DashboardSection# var: @row }#[] call_ret: ret }, location: String, name: { { DashboardSection# var: @row }#[] call_ret: ret }, login_type: { { DashboardSection# var: @row }#[] call_ret: ret }, grade: { { DashboardSection# var: @row }#[] call_ret: ret }, code: { { DashboardSection# var: @row }#[] call_ret: ret }, stage_extras: { { DashboardSection# var: @row }#[] call_ret: ret }, pairing_allowed: { { DashboardSection# var: @row }#[] call_ret: ret }, hidden: { { DashboardSection# var: @row }#[] call_ret: ret } }>","Array<{ id: Number, location: String, name: String, login_type: String, grade: String, code: String, stage_extras: (false or true), pairing_allowed: (false or true), hidden: (false or true) }>",P,Constraints,"def self.fetch_student_sections(student_id)
    return if student_id.nil?

    Dashboard.db[:sections].
      select(*fields).
      join(:followers, section_id: :id).
      join(:users, id: :student_user_id).
      where(student_user_id: student_id).
      where(sections__deleted_at: nil, followers__deleted_at: nil).
      map {|row| new(row).to_member_hash}
  end"
DashboardSection,@row,Var,@row,"({ id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true) } or { id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true), student_user_id: Number, section_id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number } or { id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true), studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number })","{ id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, deleted_at: (DateTime or Time), login_type: String, script_id: Number, login_method: Number, grade: String, admin_code: String, stage_extras: (false or true), pairing_allowed: (false or true), hidden: (false or true), course_id: Number, sharing_disabled: (false or true), student_user_id: Number, section_id: Number, email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, language: String, birthday: Date, parent_email: String, hashed_email: String, properties: String, user_type: String, school: String, full_address: String, address: String, city: String, state: String, zip: String, lat: Number, lon: Number, total_lines: Number, secret_words: String, secret_picture_id: Number, secret_word_1_id: Number, secret_word_2_id: Number }",P,Constraints,""
DashboardSection,add_student,Arg,student,"{ id: Number, admin: { { DashboardSection#add_student arg: student }#[] call_ret: ret }, name: [ to_s: () -> String ], gender: { { [s]DashboardStudent#create arg: params }#[] call_ret: ret }, age: ([ *: (Number) -> { { [s]DashboardStudent#age_to_birthday arg: age }#* call_ret: ret } ] and [ ==: (Number) -> (false or true) ] and [ to_i: () -> Number ]), birthday: { { [s]DashboardStudent#create arg: params }#[] call_ret: ret }, sharing_disabled: [ !: () -> { { { [s]DashboardStudent#create arg: params }#[] call_ret: ret }#! call_ret: ret } ] }","{ name: String, age: Number, gender: String, birthday: Date, sharing_disabled: (false or true), id: Number, admin: (false or true) }",P,Heur: hash_access,"def add_student(student)
    student_id = student[:id] || DashboardStudent.create(student)
    return nil unless student_id
    return nil if student[:admin]

    time_now = DateTime.now

    existing_follower = Dashboard.db[:followers].where(section_id: @row[:id], student_user_id: student_id).first
    if existing_follower
      Dashboard.db[:followers].where(id: existing_follower[:id]).update(deleted_at: nil, updated_at: time_now)
      return student_id
    end

    Dashboard.db[:followers].insert(
      {
        section_id: @row[:id],
        student_user_id: student_id,
        created_at: time_now,
        updated_at: time_now
      }
    )
    student_id
  end"
DashboardSection,add_student,Ret,"",Number,Number,E,Constraints,"def add_student(student)
    student_id = student[:id] || DashboardStudent.create(student)
    return nil unless student_id
    return nil if student[:admin]

    time_now = DateTime.now

    existing_follower = Dashboard.db[:followers].where(section_id: @row[:id], student_user_id: student_id).first
    if existing_follower
      Dashboard.db[:followers].where(id: existing_follower[:id]).update(deleted_at: nil, updated_at: time_now)
      return student_id
    end

    Dashboard.db[:followers].insert(
      {
        section_id: @row[:id],
        student_user_id: student_id,
        created_at: time_now,
        updated_at: time_now
      }
    )
    student_id
  end"
DashboardSection,add_students,Arg,students,[ map: () {({ { DashboardSection#add_students arg: students }#map block_arg: i }) -> { { DashboardSection#add_students arg: students }#map block_ret: block_ret }} -> { { DashboardSection#add_students arg: students }#map call_ret: ret } ],"Array<{ name: String, age: Number, gender: String, birthday: Date, sharing_disabled: (false or true), id: Number, admin: (false or true) }>",TS,Constraints,"def add_students(students)
    student_ids = students.map {|i| add_student(i)}.compact
    DashboardUserScript.assign_script_to_users(@row[:script_id], student_ids) if @row[:script_id] && !student_ids.blank?
    return student_ids
  end"
DashboardSection,add_students,Ret,"",{ DashboardSection#add_students ret: ret },Array<Number>,N,,"def add_students(students)
    student_ids = students.map {|i| add_student(i)}.compact
    DashboardUserScript.assign_script_to_users(@row[:script_id], student_ids) if @row[:script_id] && !student_ids.blank?
    return student_ids
  end"
DashboardSection,remove_student,Arg,student_id,Number,Number,E,Heur: int_names,"def remove_student(student_id)
    # BUGBUG: Need to detect ""sponsored"" accounts and disallow delete.

    rows_deleted = Dashboard.db[:followers].
      where(section_id: @row[:id], student_user_id: student_id, deleted_at: nil).
      update(deleted_at: DateTime.now)
    rows_deleted > 0
  end"
DashboardSection,remove_student,Ret,"",(false or true),(false or true),E,Constraints,"def remove_student(student_id)
    # BUGBUG: Need to detect ""sponsored"" accounts and disallow delete.

    rows_deleted = Dashboard.db[:followers].
      where(section_id: @row[:id], student_user_id: student_id, deleted_at: nil).
      update(deleted_at: DateTime.now)
    rows_deleted > 0
  end"
[s]DashboardStudent,create,Arg,params,([ []: (:age) -> { { [s]DashboardStudent#create arg: params }#[] call_ret: ret } ] and [ []: (:birthday) -> { { [s]DashboardStudent#create arg: params }#[] call_ret: ret } ] and [ []: (:gender) -> { { [s]DashboardStudent#create arg: params }#[] call_ret: ret } ] and [ []: (:name) -> { { [s]DashboardStudent#create arg: params }#[] call_ret: ret } ] and [ []: (:sharing_disabled) -> { { [s]DashboardStudent#create arg: params }#[] call_ret: ret } ]),"{ name: String, age: Number, gender: String, birthday: Date, sharing_disabled: (false or true), id: Number, admin: (false or true) }",TS,Constraints,"def self.create(params)
    name = !params[:name].to_s.empty? ? params[:name].to_s : 'New Student'
    gender = valid_gender?(params[:gender]) ? params[:gender] : nil
    birthday = age_to_birthday(params[:age]) ?
      age_to_birthday(params[:age]) : params[:birthday]
    sharing_disabled = !!params[:sharing_disabled]
    created_at = DateTime.now

    row = Dashboard.db[:users].insert(
      {
        name: name,
        user_type: 'student',
        provider: 'sponsored',
        gender: gender,
        properties: {sharing_disabled: sharing_disabled}.to_json,
        birthday: birthday,
        created_at: created_at,
        updated_at: created_at,
        username: UserHelpers.generate_username(Dashboard.db[:users], name)
      }.merge(random_secrets)
    )
    return nil unless row

    row
  end"
[s]DashboardStudent,create,Ret,"",Number,Number,E,Constraints,"def self.create(params)
    name = !params[:name].to_s.empty? ? params[:name].to_s : 'New Student'
    gender = valid_gender?(params[:gender]) ? params[:gender] : nil
    birthday = age_to_birthday(params[:age]) ?
      age_to_birthday(params[:age]) : params[:birthday]
    sharing_disabled = !!params[:sharing_disabled]
    created_at = DateTime.now

    row = Dashboard.db[:users].insert(
      {
        name: name,
        user_type: 'student',
        provider: 'sponsored',
        gender: gender,
        properties: {sharing_disabled: sharing_disabled}.to_json,
        birthday: birthday,
        created_at: created_at,
        updated_at: created_at,
        username: UserHelpers.generate_username(Dashboard.db[:users], name)
      }.merge(random_secrets)
    )
    return nil unless row

    row
  end"
DashboardCourseExperiments,@@course_experiments,Var,@@course_experiments,Array<String>,Array<String>,E,Constraints,""
[s]DashboardCourseExperiments,course_experiments,Ret,"",Array<String>,Array<String>,E,Constraints,"def self.course_experiments
    @@course_experiments ||= Dashboard.db[:course_scripts].
      exclude(experiment_name: nil).
      all.
      map {|cs| cs[:experiment_name]}
  end"
DashboardCourseExperiments,@@course_experiment_map_last_update,Var,@@course_experiment_map_last_update,Time,(Number or Time),T,Constraints,""
DashboardCourseExperiments,@@course_experiment_map,Var,@@course_experiment_map,"Hash<Number, Hash<String, (false or true)>>",%any,E,Constraints,""
[s]DashboardCourseExperiments,course_experiment_map,Ret,"","Hash<Number, Hash<String, (false or true)>>",%any,E,Constraints,"def self.course_experiment_map
    @@course_experiment_map = nil if Time.now > @@course_experiment_map_last_update + MAX_COURSE_EXPERIMENT_CACHE_SEC
    @@course_experiment_map ||= {}.tap do |map|
      @@course_experiment_map_last_update = Time.now
      Dashboard.db[:experiments].
        where(name: course_experiments, type: 'SingleUserExperiment').
        all.
        each do |row|
        user_id = row[:min_user_id]
        map[user_id] ||= {}
        map[user_id][row[:name]] = true
      end
    end
  end"
[s]DashboardSection,create,Arg,params,"{ user: { { [s]DashboardSection#create arg: params }#[] call_ret: ret }, name: [ to_s: () -> String ], login_type: [ to_s: () -> String ], grade: [ to_s: () -> String ], script: { { [s]DashboardSection#create arg: params }#[] call_ret: ret }, script_id: Number, course_id: { { [s]DashboardSection#create arg: params }#[] call_ret: ret }, stage_extras: { { [s]DashboardSection#create arg: params }#[] call_ret: ret }, pairing_allowed: [ nil?: () -> { { { [s]DashboardSection#create arg: params }#[] call_ret: ret }#nil? call_ret: ret } ] }","{ user: { user_type: String, id: Number }, name: String, login_type: String, grade: String, script: { id: Number }, script_id: Number, course_id: Number, stage_extras: (false or true), pairing_allowed: (false or true) }",P,Heur: hash_access,"def self.create(params)
    return nil unless params[:user] && params[:user][:user_type] == 'teacher'

    name = !params[:name].to_s.empty? ? params[:name].to_s : 'New Section'
    login_type =
      params[:login_type].to_s == 'none' ? 'email' : params[:login_type].to_s
    login_type = 'word' unless valid_login_type?(login_type)
    grade = valid_grade?(params[:grade].to_s) ? params[:grade].to_s : nil
    script_id = params[:script] && valid_script_id?(params[:script][:id], params[:user][:id]) ?
      params[:script][:id].to_i : params[:script_id]
    course_id = params[:course_id] && valid_course_id?(params[:course_id]) ?
      params[:course_id].to_i : nil
    stage_extras = params[:stage_extras] ? params[:stage_extras] : false
    pairing_allowed = params[:pairing_allowed].nil? ? true : params[:pairing_allowed]
    created_at = DateTime.now

    row = nil
    tries = 0
    begin
      row = Dashboard.db[:sections].insert(
        {
          user_id: params[:user][:id],
          name: name,
          login_type: login_type,
          grade: grade,
          script_id: script_id,
          course_id: course_id,
          code: CodeGeneration.random_unique_code(length: 6),
          stage_extras: stage_extras,
          pairing_allowed: pairing_allowed,
          hidden: false,
          created_at: created_at,
          updated_at: created_at,
        }
      )
    rescue Sequel::UniqueConstraintViolation
      tries += 1
      retry if tries < 3
      raise
    end

    if params[:script] && valid_script_id?(params[:script][:id], params[:user][:id])
      DashboardUserScript.assign_script_to_user(params[:script][:id].to_i, params[:user][:id])
    end

    row
  end"
[s]DashboardSection,create,Ret,"",Number,Number,E,Constraints,"def self.create(params)
    return nil unless params[:user] && params[:user][:user_type] == 'teacher'

    name = !params[:name].to_s.empty? ? params[:name].to_s : 'New Section'
    login_type =
      params[:login_type].to_s == 'none' ? 'email' : params[:login_type].to_s
    login_type = 'word' unless valid_login_type?(login_type)
    grade = valid_grade?(params[:grade].to_s) ? params[:grade].to_s : nil
    script_id = params[:script] && valid_script_id?(params[:script][:id], params[:user][:id]) ?
      params[:script][:id].to_i : params[:script_id]
    course_id = params[:course_id] && valid_course_id?(params[:course_id]) ?
      params[:course_id].to_i : nil
    stage_extras = params[:stage_extras] ? params[:stage_extras] : false
    pairing_allowed = params[:pairing_allowed].nil? ? true : params[:pairing_allowed]
    created_at = DateTime.now

    row = nil
    tries = 0
    begin
      row = Dashboard.db[:sections].insert(
        {
          user_id: params[:user][:id],
          name: name,
          login_type: login_type,
          grade: grade,
          script_id: script_id,
          course_id: course_id,
          code: CodeGeneration.random_unique_code(length: 6),
          stage_extras: stage_extras,
          pairing_allowed: pairing_allowed,
          hidden: false,
          created_at: created_at,
          updated_at: created_at,
        }
      )
    rescue Sequel::UniqueConstraintViolation
      tries += 1
      retry if tries < 3
      raise
    end

    if params[:script] && valid_script_id?(params[:script][:id], params[:user][:id])
      DashboardUserScript.assign_script_to_user(params[:script][:id].to_i, params[:user][:id])
    end

    row
  end"
[s]DashboardSection,delete_if_owner,Arg,id,Number,Number,E,Heur: int_names,"def self.delete_if_owner(id, user_id)
    row = Dashboard.db[:sections].
      where(id: id, user_id: user_id, deleted_at: nil).
      first
    return nil unless row

    time_now = Time.now

    Dashboard.db.transaction do
      Dashboard.db[:followers].where(section_id: id, deleted_at: nil).
        update(deleted_at: time_now)
      Dashboard.db[:sections].where(id: id).update(deleted_at: time_now)
    end

    row
  end"
[s]DashboardSection,delete_if_owner,Arg,user_id,Number,Number,E,Heur: int_names,"def self.delete_if_owner(id, user_id)
    row = Dashboard.db[:sections].
      where(id: id, user_id: user_id, deleted_at: nil).
      first
    return nil unless row

    time_now = Time.now

    Dashboard.db.transaction do
      Dashboard.db[:followers].where(section_id: id, deleted_at: nil).
        update(deleted_at: time_now)
      Dashboard.db[:sections].where(id: id).update(deleted_at: time_now)
    end

    row
  end"
[s]DashboardSection,delete_if_owner,Ret,"","{ id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true) }","{ id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true) }",E,Constraints,"def self.delete_if_owner(id, user_id)
    row = Dashboard.db[:sections].
      where(id: id, user_id: user_id, deleted_at: nil).
      first
    return nil unless row

    time_now = Time.now

    Dashboard.db.transaction do
      Dashboard.db[:followers].where(section_id: id, deleted_at: nil).
        update(deleted_at: time_now)
      Dashboard.db[:sections].where(id: id).update(deleted_at: time_now)
    end

    row
  end"
[s]DashboardSection,fetch_if_teacher,Arg,id,Number,Number,E,Heur: int_names,"def self.fetch_if_teacher(id, user_id)
    return nil unless row = Dashboard.db[:sections].
      select(*fields).
      where(sections__id: id, sections__user_id: user_id, sections__deleted_at: nil).
      first
    section = new(row)
    return section
  end"
[s]DashboardSection,fetch_if_teacher,Arg,user_id,Number,Number,E,Heur: int_names,"def self.fetch_if_teacher(id, user_id)
    return nil unless row = Dashboard.db[:sections].
      select(*fields).
      where(sections__id: id, sections__user_id: user_id, sections__deleted_at: nil).
      first
    section = new(row)
    return section
  end"
[s]DashboardSection,fetch_if_teacher,Ret,"",DashboardSection,DashboardSection,E,Constraints,"def self.fetch_if_teacher(id, user_id)
    return nil unless row = Dashboard.db[:sections].
      select(*fields).
      where(sections__id: id, sections__user_id: user_id, sections__deleted_at: nil).
      first
    section = new(row)
    return section
  end"
DashboardSection,@script,Var,@script,"{ id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), wrapup_video_id: Number, hidden: (false or true), user_id: Number, login_required: (false or true), properties: String, new_name: String, family_name: String }","{ id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), wrapup_video_id: Number, hidden: (false or true), user_id: Number, login_required: (false or true), properties: String, new_name: String, family_name: String }",E,Constraints,""
DashboardSection,script,Ret,"","{ id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), wrapup_video_id: Number, hidden: (false or true), user_id: Number, login_required: (false or true), properties: String, new_name: String, family_name: String }","{ id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), wrapup_video_id: Number, hidden: (false or true), user_id: Number, login_required: (false or true), properties: String, new_name: String, family_name: String }",E,Constraints,"def script
    @script ||= Dashboard.db[:scripts].
      where(id: @row[:script_id]).
      select(:id, :name).
      first
  end"
[s]DashboardStudent,random_secret_word,Ret,"",String,String,E,Constraints,"def self.random_secret_word
    random_id = SecureRandom.random_number(Dashboard.db[:secret_words].count) + 1
    Dashboard.db[:secret_words].first(id: random_id)[:word]
  end"
DashboardSection,@@script_cache,Var,@@script_cache,"([ []: (String) -> { { DashboardSection# var: @@script_cache }#[] call_ret: ret } ] and [ []=: (String, Array<{ [s]DashboardSection#assignable_info ret: ret }>) -> { { DashboardSection# var: @@script_cache }#[]= call_ret: ret } ] and [ key?: (String) -> { { DashboardSection# var: @@script_cache }#key? call_ret: ret } ])","Hash<String, Array<{ id: Number, name: String, category: String, script_name: String, position: Number, category_priority: Number }>>",TS,Constraints,""
[s]DashboardSection,valid_default_scripts,Arg,user_id,Number,Number,E,Heur: int_names,"def self.valid_default_scripts(user_id, with_hidden)
    # some users can see all scripts, even those marked hidden
    script_cache_key = I18n.locale.to_s + (with_hidden ? ""-all"" : ""-valid"")

    # only do this query once because in prod we only change scripts
    # when deploying (technically this isn't true since we are in
    # pegasus and scripts are owned by dashboard...)
    if @@script_cache.key?(script_cache_key) && !rack_env?(:levelbuilder)
      return @@script_cache[script_cache_key]
    end

    # don't crash when loading environment before database has been created
    return {} unless (Dashboard.db[:scripts].count rescue nil)

    where_clause = with_hidden ? """" : ""hidden = 0""

    # cache result if we have to actually run the query
    scripts =
      Dashboard.db[:scripts].
        where(where_clause).
        select(:id, :name, :hidden).
        all.
        map {|script| assignable_info(script[:hidden], script)}
    @@script_cache[script_cache_key] = scripts unless rack_env?(:levelbuilder)
    scripts
  end"
[s]DashboardSection,valid_default_scripts,Arg,with_hidden,Number,(false or true),T,Twin,"def self.valid_default_scripts(user_id, with_hidden)
    # some users can see all scripts, even those marked hidden
    script_cache_key = I18n.locale.to_s + (with_hidden ? ""-all"" : ""-valid"")

    # only do this query once because in prod we only change scripts
    # when deploying (technically this isn't true since we are in
    # pegasus and scripts are owned by dashboard...)
    if @@script_cache.key?(script_cache_key) && !rack_env?(:levelbuilder)
      return @@script_cache[script_cache_key]
    end

    # don't crash when loading environment before database has been created
    return {} unless (Dashboard.db[:scripts].count rescue nil)

    where_clause = with_hidden ? """" : ""hidden = 0""

    # cache result if we have to actually run the query
    scripts =
      Dashboard.db[:scripts].
        where(where_clause).
        select(:id, :name, :hidden).
        all.
        map {|script| assignable_info(script[:hidden], script)}
    @@script_cache[script_cache_key] = scripts unless rack_env?(:levelbuilder)
    scripts
  end"
[s]DashboardSection,valid_default_scripts,Ret,"","(Array<{ [s]DashboardSection#assignable_info ret: ret }> or Hash<{ [s]DashboardSection#valid_default_scripts hash_param_key: hash_param_key_#<Parser::Source::Map::Collection:0x00007fdcdef6f870> }, { [s]DashboardSection#valid_default_scripts hash_param_val: hash_param_val_#<Parser::Source::Map::Collection:0x00007fdcdef6f870> }>)","(Array<{ id: Number, name: String, category: String, script_name: String, position: Number, category_priority: Number }> or {  })",T,Constraints,"def self.valid_default_scripts(user_id, with_hidden)
    # some users can see all scripts, even those marked hidden
    script_cache_key = I18n.locale.to_s + (with_hidden ? ""-all"" : ""-valid"")

    # only do this query once because in prod we only change scripts
    # when deploying (technically this isn't true since we are in
    # pegasus and scripts are owned by dashboard...)
    if @@script_cache.key?(script_cache_key) && !rack_env?(:levelbuilder)
      return @@script_cache[script_cache_key]
    end

    # don't crash when loading environment before database has been created
    return {} unless (Dashboard.db[:scripts].count rescue nil)

    where_clause = with_hidden ? """" : ""hidden = 0""

    # cache result if we have to actually run the query
    scripts =
      Dashboard.db[:scripts].
        where(where_clause).
        select(:id, :name, :hidden).
        all.
        map {|script| assignable_info(script[:hidden], script)}
    @@script_cache[script_cache_key] = scripts unless rack_env?(:levelbuilder)
    scripts
  end"
StorageApps,users_paired_on_level?,Arg,storage_app_id,Number,Number,E,Heur: int_names,"def users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    channel_tokens_table = DASHBOARD_DB[:channel_tokens]
    level_id_row = channel_tokens_table.where(storage_app_id: storage_app_id, storage_id: owner_storage_id).first
    return false if level_id_row.nil?
    level_id = level_id_row[:level_id]

    user_levels_table = DASHBOARD_DB[:user_levels]
    owner_user_level_id = user_levels_table.select(:id).where(user_id: owner_user_id, level_id: level_id)
    current_user_level_id = user_levels_table.select(:id).where(user_id: current_user_id, level_id: level_id)

    paired_user_levels_table = DASHBOARD_DB[:paired_user_levels]
    paired_level_row = paired_user_levels_table.where(driver_user_level_id: owner_user_level_id, navigator_user_level_id: current_user_level_id).first
    return false if paired_level_row.nil?

    return true
  end"
StorageApps,users_paired_on_level?,Arg,current_user_id,Number,Number,E,Heur: int_names,"def users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    channel_tokens_table = DASHBOARD_DB[:channel_tokens]
    level_id_row = channel_tokens_table.where(storage_app_id: storage_app_id, storage_id: owner_storage_id).first
    return false if level_id_row.nil?
    level_id = level_id_row[:level_id]

    user_levels_table = DASHBOARD_DB[:user_levels]
    owner_user_level_id = user_levels_table.select(:id).where(user_id: owner_user_id, level_id: level_id)
    current_user_level_id = user_levels_table.select(:id).where(user_id: current_user_id, level_id: level_id)

    paired_user_levels_table = DASHBOARD_DB[:paired_user_levels]
    paired_level_row = paired_user_levels_table.where(driver_user_level_id: owner_user_level_id, navigator_user_level_id: current_user_level_id).first
    return false if paired_level_row.nil?

    return true
  end"
StorageApps,users_paired_on_level?,Arg,owner_user_id,Number,Number,E,Heur: int_names,"def users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    channel_tokens_table = DASHBOARD_DB[:channel_tokens]
    level_id_row = channel_tokens_table.where(storage_app_id: storage_app_id, storage_id: owner_storage_id).first
    return false if level_id_row.nil?
    level_id = level_id_row[:level_id]

    user_levels_table = DASHBOARD_DB[:user_levels]
    owner_user_level_id = user_levels_table.select(:id).where(user_id: owner_user_id, level_id: level_id)
    current_user_level_id = user_levels_table.select(:id).where(user_id: current_user_id, level_id: level_id)

    paired_user_levels_table = DASHBOARD_DB[:paired_user_levels]
    paired_level_row = paired_user_levels_table.where(driver_user_level_id: owner_user_level_id, navigator_user_level_id: current_user_level_id).first
    return false if paired_level_row.nil?

    return true
  end"
StorageApps,users_paired_on_level?,Arg,owner_storage_id,Number,Number,E,Heur: int_names,"def users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    channel_tokens_table = DASHBOARD_DB[:channel_tokens]
    level_id_row = channel_tokens_table.where(storage_app_id: storage_app_id, storage_id: owner_storage_id).first
    return false if level_id_row.nil?
    level_id = level_id_row[:level_id]

    user_levels_table = DASHBOARD_DB[:user_levels]
    owner_user_level_id = user_levels_table.select(:id).where(user_id: owner_user_id, level_id: level_id)
    current_user_level_id = user_levels_table.select(:id).where(user_id: current_user_id, level_id: level_id)

    paired_user_levels_table = DASHBOARD_DB[:paired_user_levels]
    paired_level_row = paired_user_levels_table.where(driver_user_level_id: owner_user_level_id, navigator_user_level_id: current_user_level_id).first
    return false if paired_level_row.nil?

    return true
  end"
StorageApps,users_paired_on_level?,Ret,"",(false or true),(false or true),E,Constraints,"def users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    channel_tokens_table = DASHBOARD_DB[:channel_tokens]
    level_id_row = channel_tokens_table.where(storage_app_id: storage_app_id, storage_id: owner_storage_id).first
    return false if level_id_row.nil?
    level_id = level_id_row[:level_id]

    user_levels_table = DASHBOARD_DB[:user_levels]
    owner_user_level_id = user_levels_table.select(:id).where(user_id: owner_user_id, level_id: level_id)
    current_user_level_id = user_levels_table.select(:id).where(user_id: current_user_id, level_id: level_id)

    paired_user_levels_table = DASHBOARD_DB[:paired_user_levels]
    paired_level_row = paired_user_levels_table.where(driver_user_level_id: owner_user_level_id, navigator_user_level_id: current_user_level_id).first
    return false if paired_level_row.nil?

    return true
  end"
StorageApps,@storage_id,Var,@storage_id,Number,Number,E,Heur: int_names,""
StorageApps,@table,Var,@table,"Table<{ id: Number, storage_id: Number, value: String, updated_at: (DateTime or Time), updated_ip: String, state: String, created_at: (DateTime or Time), abuse_score: Number, project_type: String, published_at: (DateTime or Time), standalone: (false or true), remix_parent_id: Number, __selected: nil, __last_joined: :storage_apps, __all_joined: :storage_apps, __orm: false }>","Table<{ id: Number, storage_id: Number, value: String, updated_at: (DateTime or Time), updated_ip: String, state: String, created_at: (DateTime or Time), abuse_score: Number, project_type: String, published_at: (DateTime or Time), standalone: (false or true), remix_parent_id: Number, __selected: nil, __last_joined: :storage_apps, __all_joined: :storage_apps, __orm: false }>",E,Constraints,""
StorageApps,initialize,Arg,storage_id,Number,Number,E,Constraints,"def initialize(storage_id)
    @storage_id = storage_id

    @table = PEGASUS_DB[:storage_apps]
  end"
StorageApps,initialize,Ret,"",self,self,E,,"def initialize(storage_id)
    @storage_id = storage_id

    @table = PEGASUS_DB[:storage_apps]
  end"
StorageApps,create,Arg,value,String,String,E,Twin,"def create(value, ip:, type: nil, published_at: nil, remix_parent_id: nil)
    timestamp = DateTime.now
    row = {
      storage_id: @storage_id,
      value: value.to_json,
      created_at: timestamp,
      updated_at: timestamp,
      updated_ip: ip,
      abuse_score: 0,
      project_type: type,
      published_at: published_at,
      remix_parent_id: remix_parent_id,
    }
    row[:id] = @table.insert(row)

    storage_encrypt_channel_id(row[:storage_id], row[:id])
  end"
StorageApps,create,Arg,"{ ip: { StorageApps#create arg: ip }, type: ?{ StorageApps#create arg: type }, published_at: ?{ StorageApps#create arg: published_at }, remix_parent_id: ?{ StorageApps#create arg: remix_parent_id } }","{ ip: String, type: ?String, published_at: ?((DateTime or Time)), remix_parent_id: ?Number }","{ ip: String, type: ?String, published_at: ?DateTime, remix_parent_id: ?Number }",P,TODO: handle FHTs,"def create(value, ip:, type: nil, published_at: nil, remix_parent_id: nil)
    timestamp = DateTime.now
    row = {
      storage_id: @storage_id,
      value: value.to_json,
      created_at: timestamp,
      updated_at: timestamp,
      updated_ip: ip,
      abuse_score: 0,
      project_type: type,
      published_at: published_at,
      remix_parent_id: remix_parent_id,
    }
    row[:id] = @table.insert(row)

    storage_encrypt_channel_id(row[:storage_id], row[:id])
  end"
StorageApps,create,Ret,"",String,String,E,Constraints,"def create(value, ip:, type: nil, published_at: nil, remix_parent_id: nil)
    timestamp = DateTime.now
    row = {
      storage_id: @storage_id,
      value: value.to_json,
      created_at: timestamp,
      updated_at: timestamp,
      updated_ip: ip,
      abuse_score: 0,
      project_type: type,
      published_at: published_at,
      remix_parent_id: remix_parent_id,
    }
    row[:id] = @table.insert(row)

    storage_encrypt_channel_id(row[:storage_id], row[:id])
  end"
StorageApps,delete,Arg,channel_id,String,String,E,Twin,"def delete(channel_id)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id

    delete_count = @table.where(id: id).update(state: 'deleted')
    raise NotFound, ""channel `#{channel_id}` not found"" if delete_count == 0

    # TODO: Delete all storage associated with this channel (e.g. properties and tables and assets)

    true
  end"
StorageApps,delete,Ret,"",(false or true),(false or true),E,Constraints,"def delete(channel_id)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id

    delete_count = @table.where(id: id).update(state: 'deleted')
    raise NotFound, ""channel `#{channel_id}` not found"" if delete_count == 0

    # TODO: Delete all storage associated with this channel (e.g. properties and tables and assets)

    true
  end"
StorageApps,publish,Arg,channel_id,(Number and String),String,T,Constraints,"def publish(channel_id, type, user)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id
    row = {
      project_type: type,
      published_at: DateTime.now,
    }
    update_count = @table.where(id: id).exclude(state: 'deleted').update(row)
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    project = @table.where(id: id).first

    StorageApps.get_published_project_data(channel_id, project).merge(
      # For privacy reasons, include only the first initial of the student's name.
      studentName: user && UserHelpers.initial(user[:name]),
      studentAgeRange: user && UserHelpers.age_range_from_birthday(user[:birthday]),
    )
  end"
StorageApps,publish,Arg,type,String,String,E,Constraints,"def publish(channel_id, type, user)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id
    row = {
      project_type: type,
      published_at: DateTime.now,
    }
    update_count = @table.where(id: id).exclude(state: 'deleted').update(row)
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    project = @table.where(id: id).first

    StorageApps.get_published_project_data(channel_id, project).merge(
      # For privacy reasons, include only the first initial of the student's name.
      studentName: user && UserHelpers.initial(user[:name]),
      studentAgeRange: user && UserHelpers.age_range_from_birthday(user[:birthday]),
    )
  end"
StorageApps,publish,Arg,user,User,"{ name: String, birthday: DateTime }",T,Heur: is_model,"def publish(channel_id, type, user)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id
    row = {
      project_type: type,
      published_at: DateTime.now,
    }
    update_count = @table.where(id: id).exclude(state: 'deleted').update(row)
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    project = @table.where(id: id).first

    StorageApps.get_published_project_data(channel_id, project).merge(
      # For privacy reasons, include only the first initial of the student's name.
      studentName: user && UserHelpers.initial(user[:name]),
      studentAgeRange: user && UserHelpers.age_range_from_birthday(user[:birthday]),
    )
  end"
StorageApps,publish,Ret,"","{ channel: { [s]StorageApps#get_published_project_data arg: channel_id }, name: Object, thumbnailUrl: { [s]StorageApps#make_thumbnail_url_cacheable ret: ret }, type: { { [s]StorageApps#get_published_project_data arg: project }#[] call_ret: ret }, publishedAt: { { [s]StorageApps#get_published_project_data arg: project }#[] call_ret: ret }, studentName: ({ StorageApps#publish arg: user } or { [s]UserHelpers#initial ret: ret }), studentAgeRange: ({ StorageApps#publish arg: user } or { [s]UserHelpers#age_range_from_birthday ret: ret }) }","{ channel: Number, name: String, thumbnailUrl: String, type: String, publishedAt: DateTime, studentName: (String or { name: String, birthday: DateTime }), studentAgeRange: (String or { name: String, birthday: DateTime }) }",P,Constraints,"def publish(channel_id, type, user)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id
    row = {
      project_type: type,
      published_at: DateTime.now,
    }
    update_count = @table.where(id: id).exclude(state: 'deleted').update(row)
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    project = @table.where(id: id).first

    StorageApps.get_published_project_data(channel_id, project).merge(
      # For privacy reasons, include only the first initial of the student's name.
      studentName: user && UserHelpers.initial(user[:name]),
      studentAgeRange: user && UserHelpers.age_range_from_birthday(user[:birthday]),
    )
  end"
StorageApps,unpublish,Arg,channel_id,String,String,E,Twin,"def unpublish(channel_id)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id
    row = {
      published_at: nil,
    }
    update_count = @table.where(id: id).exclude(state: 'deleted').update(row)
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0
  end"
StorageApps,unpublish,Ret,"",nil,Number,T,Constraints,"def unpublish(channel_id)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id
    row = {
      published_at: nil,
    }
    update_count = @table.where(id: id).exclude(state: 'deleted').update(row)
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0
  end"
StorageApps,get_abuse,Arg,channel_id,String,String,E,Twin,"def get_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    row[:abuse_score]
  end"
StorageApps,get_abuse,Ret,"",String,Number,T,Twin,"def get_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    row[:abuse_score]
  end"
StorageApps,get_sharing_disabled,Arg,channel_id,String,String,E,Twin,"def get_sharing_disabled(channel_id, current_user_id)
    owner_storage_id, storage_app_id = storage_decrypt_channel_id(channel_id)
    owner_user_id = user_storage_ids_table.where(id: owner_storage_id).first[:user_id]

    # Sharing of a project is not disabled for the project owner
    # or the teachers of the project owner
    # or if the current user paired with the owner
    if current_user_id == owner_user_id
      return false
    elsif teaches_student?(owner_user_id, current_user_id)
      return false
    elsif get_user_sharing_disabled(owner_user_id)
      !users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    else
      return false
    end

  # Default to sharing disabled if there is an error
  rescue ArgumentError, OpenSSL::Cipher::CipherError
    true
  end"
StorageApps,get_sharing_disabled,Arg,current_user_id,Number,Number,E,Constraints,"def get_sharing_disabled(channel_id, current_user_id)
    owner_storage_id, storage_app_id = storage_decrypt_channel_id(channel_id)
    owner_user_id = user_storage_ids_table.where(id: owner_storage_id).first[:user_id]

    # Sharing of a project is not disabled for the project owner
    # or the teachers of the project owner
    # or if the current user paired with the owner
    if current_user_id == owner_user_id
      return false
    elsif teaches_student?(owner_user_id, current_user_id)
      return false
    elsif get_user_sharing_disabled(owner_user_id)
      !users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    else
      return false
    end

  # Default to sharing disabled if there is an error
  rescue ArgumentError, OpenSSL::Cipher::CipherError
    true
  end"
StorageApps,get_sharing_disabled,Ret,"",(false or true),(false or true),E,Constraints,"def get_sharing_disabled(channel_id, current_user_id)
    owner_storage_id, storage_app_id = storage_decrypt_channel_id(channel_id)
    owner_user_id = user_storage_ids_table.where(id: owner_storage_id).first[:user_id]

    # Sharing of a project is not disabled for the project owner
    # or the teachers of the project owner
    # or if the current user paired with the owner
    if current_user_id == owner_user_id
      return false
    elsif teaches_student?(owner_user_id, current_user_id)
      return false
    elsif get_user_sharing_disabled(owner_user_id)
      !users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    else
      return false
    end

  # Default to sharing disabled if there is an error
  rescue ArgumentError, OpenSSL::Cipher::CipherError
    true
  end"
StorageApps,increment_abuse,Arg,channel_id,String,String,E,Twin,"def increment_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    new_score = row[:abuse_score] + (JSON.parse(row[:value])['frozen'] ? 0 : 10)

    update_count = @table.where(id: id).exclude(state: 'deleted').update({abuse_score: new_score})
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    new_score
  end"
StorageApps,increment_abuse,Ret,"",String,Number,T,Twin,"def increment_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    new_score = row[:abuse_score] + (JSON.parse(row[:value])['frozen'] ? 0 : 10)

    update_count = @table.where(id: id).exclude(state: 'deleted').update({abuse_score: new_score})
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    new_score
  end"
StorageApps,reset_abuse,Arg,channel_id,String,String,E,Twin,"def reset_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    update_count = @table.where(id: id).exclude(state: 'deleted').update({abuse_score: 0})
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    0
  end"
StorageApps,reset_abuse,Ret,"",Number,Number,E,Constraints,"def reset_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    update_count = @table.where(id: id).exclude(state: 'deleted').update({abuse_score: 0})
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    0
  end"
Dashboard::User,initialize,Arg,user_row,"{ id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }",``fht(targs[0])``,T,Constraints,"def initialize(user_row)
      @row = user_row
    end"
Dashboard::User,initialize,Ret,"",self,self,E,,"def initialize(user_row)
      @row = user_row
    end"
Dashboard::User,id,Ret,"",Number,Number,E,Constraints,"def id
      @row[:id]
    end"
Dashboard::User,teacher?,Ret,"",(false or true),(false or true),E,Constraints,"def teacher?
      @row[:user_type] == 'teacher'
    end"
Object,current_user_id,Ret,"",Number,Number,E,Heur: int_names,"def current_user_id
  # @request is a Sinatra::Request < Rack::Request provided by Sinatra::Base
  @request.nil? ? nil : @request.user_id
end"
[s]DashboardStudent,encrypt_password,Arg,password,String,String,E,Twin,"def self.encrypt_password(password)
    BCrypt::Password.create(""#{password}#{PEPPER}"", cost: STRETCHES).to_s
  end"
[s]DashboardStudent,encrypt_password,Ret,"",String,String,E,Constraints,"def self.encrypt_password(password)
    BCrypt::Password.create(""#{password}#{PEPPER}"", cost: STRETCHES).to_s
  end"
[s]DashboardStudent,valid_gender?,Arg,gender,String,String,E,Twin,"def self.valid_gender?(gender)
    VALID_GENDERS.include?(gender)
  end"
[s]DashboardStudent,valid_gender?,Ret,"",(false or true),(false or true),E,Constraints,"def self.valid_gender?(gender)
    VALID_GENDERS.include?(gender)
  end"
[s]DashboardStudent,birthday_to_age,Arg,birthday,[ nil?: () -> { { [s]DashboardStudent#birthday_to_age arg: birthday }#nil? call_ret: ret } ],Date,TS,Constraints,"def self.birthday_to_age(birthday)
    return if birthday.nil?
    age = ((Date.today - birthday) / 365).to_i # TODO: Should this be 365.25?
    age = ""21+"" if age >= 21
    age
  end"
[s]DashboardStudent,birthday_to_age,Ret,"",(Number or String),(Number or String),E,Constraints,"def self.birthday_to_age(birthday)
    return if birthday.nil?
    age = ((Date.today - birthday) / 365).to_i # TODO: Should this be 365.25?
    age = ""21+"" if age >= 21
    age
  end"
[s]DashboardStudent,age_to_birthday,Arg,age,([ *: (Number) -> { { [s]DashboardStudent#age_to_birthday arg: age }#* call_ret: ret } ] and [ ==: (Number) -> (false or true) ] and [ to_i: () -> Number ]),(Number or String),TS,Constraints,"def self.age_to_birthday(age)
    age = age.to_i
    return nil if age == 0
    Date.today - age * 365
  end"
[s]DashboardStudent,age_to_birthday,Ret,"",%any,Date,T,Constraints,"def self.age_to_birthday(age)
    age = age.to_i
    return nil if age == 0
    Date.today - age * 365
  end"
[s]DashboardStudent,random_secret_words,Ret,"",String,String,E,Constraints,"def self.random_secret_words
    ""#{random_secret_word} #{random_secret_word}""
  end"
[s]DashboardSection,valid_login_type?,Arg,login_type,String,String,E,Twin,"def self.valid_login_type?(login_type)
    valid_login_types.include? login_type
  end"
[s]DashboardSection,valid_login_type?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def self.valid_login_type?(login_type)
    valid_login_types.include? login_type
  end"
[s]DashboardSection,valid_grade?,Arg,grade,String,String,E,Twin,"def self.valid_grade?(grade)
    valid_grades.include? grade
  end"
[s]DashboardSection,valid_grade?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def self.valid_grade?(grade)
    valid_grades.include? grade
  end"
[s]DashboardSection,valid_course_id?,Arg,course_id,Number,Number,E,Heur: int_names,"def self.valid_course_id?(course_id)
    valid_courses.any? {|course| course[:id] == course_id.to_i}
  end"
[s]DashboardSection,valid_course_id?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def self.valid_course_id?(course_id)
    valid_courses.any? {|course| course[:id] == course_id.to_i}
  end"
[s]DashboardSection,valid_script_id?,Arg,script_id,Number,Number,E,Heur: int_names,"def self.valid_script_id?(script_id, user_id = nil)
    valid_scripts(user_id).any? {|script| script[:id] == script_id.to_i}
  end"
[s]DashboardSection,valid_script_id?,Arg,user_id,?Number,?Number,E,Constraints,"def self.valid_script_id?(script_id, user_id = nil)
    valid_scripts(user_id).any? {|script| script[:id] == script_id.to_i}
  end"
[s]DashboardSection,valid_script_id?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def self.valid_script_id?(script_id, user_id = nil)
    valid_scripts(user_id).any? {|script| script[:id] == script_id.to_i}
  end"
DashboardSection,to_member_hash,Ret,"","{ id: { { DashboardSection# var: @row }#[] call_ret: ret }, location: String, name: { { DashboardSection# var: @row }#[] call_ret: ret }, login_type: { { DashboardSection# var: @row }#[] call_ret: ret }, grade: { { DashboardSection# var: @row }#[] call_ret: ret }, code: { { DashboardSection# var: @row }#[] call_ret: ret }, stage_extras: { { DashboardSection# var: @row }#[] call_ret: ret }, pairing_allowed: { { DashboardSection# var: @row }#[] call_ret: ret }, hidden: { { DashboardSection# var: @row }#[] call_ret: ret } }","{ id: Number, location: String, name: String, login_type: String, grade: String, code: String, stage_extras: (false or true), pairing_allowed: (false or true), hidden: (false or true) }",P,Constraints,"def to_member_hash
    {
      id: @row[:id],
      location: ""/v2/sections/#{@row[:id]}"",
      name: @row[:name],
      login_type: @row[:login_type],
      grade: @row[:grade],
      code: @row[:code],
      stage_extras: @row[:stage_extras],
      pairing_allowed: @row[:pairing_allowed],
      hidden: @row[:hidden],
    }
  end"
DashboardSection,to_owner_hash,Ret,"","{ id: { { DashboardSection# var: @row }#[] call_ret: ret }, location: String, name: { { DashboardSection# var: @row }#[] call_ret: ret }, login_type: { { DashboardSection# var: @row }#[] call_ret: ret }, grade: { { DashboardSection# var: @row }#[] call_ret: ret }, code: { { DashboardSection# var: @row }#[] call_ret: ret }, stage_extras: { { DashboardSection# var: @row }#[] call_ret: ret }, pairing_allowed: { { DashboardSection# var: @row }#[] call_ret: ret }, hidden: { { DashboardSection# var: @row }#[] call_ret: ret }, script: { DashboardSection#script ret: ret }, course_id: { { DashboardSection# var: @row }#[] call_ret: ret }, teachers: { DashboardSection#teachers ret: ret }, students: { DashboardSection#students ret: ret }, studentCount: { { DashboardSection#students ret: ret }#count call_ret: ret } }","{ id: Number, location: String, name: String, login_type: String, grade: String, code: String, stage_extras: (false or true), pairing_allowed: (false or true), hidden: (false or true), script: { id: Number }, teachers: { id: Number, location: String }, students: {  }, studentCount: Number }",P,Constraints,"def to_owner_hash
    to_member_hash.merge(
      script: script,
      course_id: @row[:course_id],
      teachers: teachers,
      students: students,
      studentCount: students.count,
    )
  end"
DashboardSection,initialize,Arg,row,"(({ id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true) } or { id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true), student_user_id: Number, section_id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number } or { id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true), studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }) and [ []: (:course_id) -> { { DashboardSection# var: @row }#[] call_ret: ret } ] and [ []: (:grade) -> { { DashboardSection# var: @row }#[] call_ret: ret } ] and [ []: (:hidden) -> { { DashboardSection# var: @row }#[] call_ret: ret } ] and [ []: (:id) -> { { DashboardSection# var: @row }#[] call_ret: ret } ] and [ []: (:login_type) -> { { DashboardSection# var: @row }#[] call_ret: ret } ] and [ []: (:name) -> { { DashboardSection# var: @row }#[] call_ret: ret } ] and [ []: (:pairing_allowed) -> { { DashboardSection# var: @row }#[] call_ret: ret } ] and [ []: (:script_id) -> { { DashboardSection# var: @row }#[] call_ret: ret } ] and [ []: (:stage_extras) -> { { DashboardSection# var: @row }#[] call_ret: ret } ])",%any,E,Constraints,"def initialize(row)
    @row = row
  end"
DashboardSection,initialize,Ret,"",self,self,E,,"def initialize(row)
    @row = row
  end"
[s]UserHelpers,generate_username,Arg,queryable,([ respond_to?: (:connection) -> { { [s]UserHelpers#generate_username arg: queryable }#respond_to? call_ret: ret } ] and [ where: ({ username: (String or { { { { { { [s]UserHelpers#generate_username arg: name }#downcase call_ret: ret }#gsub call_ret: ret }#[] call_ret: ret }#squish call_ret: ret }#tr call_ret: ret }) }) -> { { [s]UserHelpers#generate_username arg: queryable }#where call_ret: ret } ]),%any,E,Constraints,"def self.generate_username(queryable, name)
    prefix = name.downcase.
      gsub(/[^#{USERNAME_ALLOWED_CHARACTERS.source}]+/, ' ')[0..USERNAME_MAX_LENGTH - 5].
      squish.
      tr(' ', '_')

    if prefix.empty? || prefix == ''
      prefix = 'coder' + rand(100000..999999).to_s
    end
    prefix = ""coder_#{prefix}"" if prefix.length < 5

    return prefix if queryable.where(username: prefix).limit(1).empty?

    # Throw random darts of increasing length (3 to 7 digits) to find an unused suffix.
    (2..6).each do |exponent|
      min_index = 10**exponent
      max_index = 10**(exponent + 1) - 1
      2.times do |_i|
        suffix = Random.rand(min_index..max_index)
        # Truncate generated username to max allowed length.
        username = ""#{prefix}#{suffix}""[0..USERNAME_MAX_LENGTH - 1]
        if queryable.where(username: username).limit(1).empty?
          return username
        end
      end
    end

    # Fallback to a range-scan query to find an available gap in the integer sequence.

    # Use CAST() and SUBSTRING() to parse the suffix as an integer.
    cast = lambda {|t| ""CAST(SUBSTRING(#{t}, #{prefix.length + 1}) as unsigned)""}

    query = <<SQL
SELECT #{cast.call('username')} + 1
  FROM users u
  WHERE username LIKE ""#{prefix}%""
    AND username RLIKE ""^#{prefix}[0-9]+$""
    AND NOT EXISTS (
      SELECT 1
      FROM users u2
      WHERE u2.username = CONCAT(""#{prefix}"", #{cast.call('u.username')} + 1)
    )
  LIMIT 1;
SQL
    # Execute raw query using either ActiveRecord or Sequel object.
    # MKCHANGE
    next_id = queryable.respond_to?(:connection) ?
      RDL.type_cast(queryable, ""ActiveRecord::ConnectionHandling"").connection.execute(query).first.first :
      RDL.type_cast(queryable, ""Sequel::Dataset"").db.fetch(query).first.values.first
    username = ""#{prefix}#{next_id}""
    raise ""generate_username overflow: #{username}"" if username.length > USERNAME_MAX_LENGTH
    username
  end"
[s]UserHelpers,generate_username,Arg,name,String,String,E,Heur: string_name,"def self.generate_username(queryable, name)
    prefix = name.downcase.
      gsub(/[^#{USERNAME_ALLOWED_CHARACTERS.source}]+/, ' ')[0..USERNAME_MAX_LENGTH - 5].
      squish.
      tr(' ', '_')

    if prefix.empty? || prefix == ''
      prefix = 'coder' + rand(100000..999999).to_s
    end
    prefix = ""coder_#{prefix}"" if prefix.length < 5

    return prefix if queryable.where(username: prefix).limit(1).empty?

    # Throw random darts of increasing length (3 to 7 digits) to find an unused suffix.
    (2..6).each do |exponent|
      min_index = 10**exponent
      max_index = 10**(exponent + 1) - 1
      2.times do |_i|
        suffix = Random.rand(min_index..max_index)
        # Truncate generated username to max allowed length.
        username = ""#{prefix}#{suffix}""[0..USERNAME_MAX_LENGTH - 1]
        if queryable.where(username: username).limit(1).empty?
          return username
        end
      end
    end

    # Fallback to a range-scan query to find an available gap in the integer sequence.

    # Use CAST() and SUBSTRING() to parse the suffix as an integer.
    cast = lambda {|t| ""CAST(SUBSTRING(#{t}, #{prefix.length + 1}) as unsigned)""}

    query = <<SQL
SELECT #{cast.call('username')} + 1
  FROM users u
  WHERE username LIKE ""#{prefix}%""
    AND username RLIKE ""^#{prefix}[0-9]+$""
    AND NOT EXISTS (
      SELECT 1
      FROM users u2
      WHERE u2.username = CONCAT(""#{prefix}"", #{cast.call('u.username')} + 1)
    )
  LIMIT 1;
SQL
    # Execute raw query using either ActiveRecord or Sequel object.
    # MKCHANGE
    next_id = queryable.respond_to?(:connection) ?
      RDL.type_cast(queryable, ""ActiveRecord::ConnectionHandling"").connection.execute(query).first.first :
      RDL.type_cast(queryable, ""Sequel::Dataset"").db.fetch(query).first.values.first
    username = ""#{prefix}#{next_id}""
    raise ""generate_username overflow: #{username}"" if username.length > USERNAME_MAX_LENGTH
    username
  end"
[s]UserHelpers,generate_username,Ret,"",String,String,E,Constraints,"def self.generate_username(queryable, name)
    prefix = name.downcase.
      gsub(/[^#{USERNAME_ALLOWED_CHARACTERS.source}]+/, ' ')[0..USERNAME_MAX_LENGTH - 5].
      squish.
      tr(' ', '_')

    if prefix.empty? || prefix == ''
      prefix = 'coder' + rand(100000..999999).to_s
    end
    prefix = ""coder_#{prefix}"" if prefix.length < 5

    return prefix if queryable.where(username: prefix).limit(1).empty?

    # Throw random darts of increasing length (3 to 7 digits) to find an unused suffix.
    (2..6).each do |exponent|
      min_index = 10**exponent
      max_index = 10**(exponent + 1) - 1
      2.times do |_i|
        suffix = Random.rand(min_index..max_index)
        # Truncate generated username to max allowed length.
        username = ""#{prefix}#{suffix}""[0..USERNAME_MAX_LENGTH - 1]
        if queryable.where(username: username).limit(1).empty?
          return username
        end
      end
    end

    # Fallback to a range-scan query to find an available gap in the integer sequence.

    # Use CAST() and SUBSTRING() to parse the suffix as an integer.
    cast = lambda {|t| ""CAST(SUBSTRING(#{t}, #{prefix.length + 1}) as unsigned)""}

    query = <<SQL
SELECT #{cast.call('username')} + 1
  FROM users u
  WHERE username LIKE ""#{prefix}%""
    AND username RLIKE ""^#{prefix}[0-9]+$""
    AND NOT EXISTS (
      SELECT 1
      FROM users u2
      WHERE u2.username = CONCAT(""#{prefix}"", #{cast.call('u.username')} + 1)
    )
  LIMIT 1;
SQL
    # Execute raw query using either ActiveRecord or Sequel object.
    # MKCHANGE
    next_id = queryable.respond_to?(:connection) ?
      RDL.type_cast(queryable, ""ActiveRecord::ConnectionHandling"").connection.execute(query).first.first :
      RDL.type_cast(queryable, ""Sequel::Dataset"").db.fetch(query).first.values.first
    username = ""#{prefix}#{next_id}""
    raise ""generate_username overflow: #{username}"" if username.length > USERNAME_MAX_LENGTH
    username
  end"
DashboardSection,member?,Arg,user_id,Number,Number,E,Heur: int_names,"def member?(user_id)
    return teacher?(user_id) || student?(user_id)
  end"
DashboardSection,member?,Ret,"",(false or true),(false or true),E,Heur: predicate_method,"def member?(user_id)
    return teacher?(user_id) || student?(user_id)
  end"
[s]DashboardSection,assignable_info,Arg,hidden,{ [s]DashboardSection#assignable_info arg: hidden },(false or true),N,,"def self.assignable_info(hidden, course_or_script) ## MKCHANGE: changed argument order
    info = ScriptConstants.assignable_info(course_or_script)
    info[:name] = I18n.t(""#{info[:name]}_name"", default: info[:name])
    info[:name] += "" *"" if hidden

    info[:category] = I18n.t(""#{info[:category]}_category_name"", default: info[:category])

    info
  end"
[s]DashboardSection,assignable_info,Arg,course_or_script,{ [s]DashboardSection#assignable_info arg: course_or_script },"{ name: String, hidden: (false or true), id: Number }",N,,"def self.assignable_info(hidden, course_or_script) ## MKCHANGE: changed argument order
    info = ScriptConstants.assignable_info(course_or_script)
    info[:name] = I18n.t(""#{info[:name]}_name"", default: info[:name])
    info[:name] += "" *"" if hidden

    info[:category] = I18n.t(""#{info[:category]}_category_name"", default: info[:category])

    info
  end"
[s]DashboardSection,assignable_info,Ret,"",{ [s]DashboardSection#assignable_info ret: ret },"{ id: Number, name: String, category: String, script_name: String, position: Number, category_priority: Number }",N,,"def self.assignable_info(hidden, course_or_script) ## MKCHANGE: changed argument order
    info = ScriptConstants.assignable_info(course_or_script)
    info[:name] = I18n.t(""#{info[:name]}_name"", default: info[:name])
    info[:name] += "" *"" if hidden

    info[:category] = I18n.t(""#{info[:category]}_category_name"", default: info[:category])

    info
  end"
Object,get_sharing_disabled_from_properties,Arg,properties,String,String,E,Constraints,"def get_sharing_disabled_from_properties(properties)
  return false unless properties
  parsed_properties = JSON.parse(properties)
  !!parsed_properties[""sharing_disabled""]
end"
Object,get_sharing_disabled_from_properties,Ret,"",(false or true),(false or true),E,Constraints,"def get_sharing_disabled_from_properties(properties)
  return false unless properties
  parsed_properties = JSON.parse(properties)
  !!parsed_properties[""sharing_disabled""]
end"
Object,storage_encrypt_channel_id,Arg,storage_id,Number,Number,E,Heur: int_names,"def storage_encrypt_channel_id(storage_id, channel_id)
  storage_id = storage_id.to_i
  raise ArgumentError, ""`storage_id` must be an integer > 0"" unless storage_id > 0
  channel_id = channel_id.to_i
  raise ArgumentError, ""`channel_id` must be an integer > 0"" unless channel_id > 0
  Base64.urlsafe_encode64(storage_encrypt(""#{storage_id}:#{channel_id}"")).tr('=', '')
end"
Object,storage_encrypt_channel_id,Arg,channel_id,Number,Number,E,Heur: int_names,"def storage_encrypt_channel_id(storage_id, channel_id)
  storage_id = storage_id.to_i
  raise ArgumentError, ""`storage_id` must be an integer > 0"" unless storage_id > 0
  channel_id = channel_id.to_i
  raise ArgumentError, ""`channel_id` must be an integer > 0"" unless channel_id > 0
  Base64.urlsafe_encode64(storage_encrypt(""#{storage_id}:#{channel_id}"")).tr('=', '')
end"
Object,storage_encrypt_channel_id,Ret,"",String,String,E,Constraints,"def storage_encrypt_channel_id(storage_id, channel_id)
  storage_id = storage_id.to_i
  raise ArgumentError, ""`storage_id` must be an integer > 0"" unless storage_id > 0
  channel_id = channel_id.to_i
  raise ArgumentError, ""`channel_id` must be an integer > 0"" unless channel_id > 0
  Base64.urlsafe_encode64(storage_encrypt(""#{storage_id}:#{channel_id}"")).tr('=', '')
end"
Object,storage_decrypt_channel_id,Arg,encrypted,String,String,E,Twin,"def storage_decrypt_channel_id(encrypted)
  raise ArgumentError, ""`encrypted` must be a string"" unless encrypted.is_a? String
  # pad to a multiple of 4 characters to make a valid base64 string.
  encrypted += '=' * ((4 - encrypted.length % 4) % 4)
  storage_id, channel_id = storage_decrypt(Base64.urlsafe_decode64(encrypted)).split(':').map(&:to_i)
  raise ArgumentError, ""`storage_id` must be an integer > 0"" unless storage_id > 0
  raise ArgumentError, ""`channel_id` must be an integer > 0"" unless channel_id > 0
  [storage_id, channel_id]
end"
Object,storage_decrypt_channel_id,Ret,"","[{ Object#storage_decrypt_channel_id tuple_element: tuple_element_0 }, { Object#storage_decrypt_channel_id tuple_element: tuple_element_0 }]","[Number, Number]",P,Constraints,"def storage_decrypt_channel_id(encrypted)
  raise ArgumentError, ""`encrypted` must be a string"" unless encrypted.is_a? String
  # pad to a multiple of 4 characters to make a valid base64 string.
  encrypted += '=' * ((4 - encrypted.length % 4) % 4)
  storage_id, channel_id = storage_decrypt(Base64.urlsafe_decode64(encrypted)).split(':').map(&:to_i)
  raise ArgumentError, ""`storage_id` must be an integer > 0"" unless storage_id > 0
  raise ArgumentError, ""`channel_id` must be an integer > 0"" unless channel_id > 0
  [storage_id, channel_id]
end"
[s]StorageApps,get_published_project_data,Arg,channel_id,Number,Number,E,Heur: int_names,"def self.get_published_project_data(channel_id, project) ## MKCHANGE: changed arg positions
    project_value = JSON.parse(project[:value])
    {
      channel: channel_id,
      name: project_value['name'],
      thumbnailUrl: StorageApps.make_thumbnail_url_cacheable(project_value['thumbnailUrl']),
      # Note that we are using the new :project_type field rather than extracting
      # it from :value. :project_type might not be present in unpublished projects.
      type: project[:project_type],
      publishedAt: project[:published_at],
    }
  end"
[s]StorageApps,get_published_project_data,Arg,project,"{ value: String, project_type: { { [s]StorageApps#get_published_project_data arg: project }#[] call_ret: ret }, published_at: { { [s]StorageApps#get_published_project_data arg: project }#[] call_ret: ret } }","{ id: Number, storage_id: Number, value: String, updated_at: (DateTime or Time), updated_ip: String, state: String, created_at: (DateTime or Time), abuse_score: Number, project_type: String, published_at: (DateTime or Time), standalone: (false or true), remix_parent_id: Number }",P,Heur: hash_access,"def self.get_published_project_data(channel_id, project) ## MKCHANGE: changed arg positions
    project_value = JSON.parse(project[:value])
    {
      channel: channel_id,
      name: project_value['name'],
      thumbnailUrl: StorageApps.make_thumbnail_url_cacheable(project_value['thumbnailUrl']),
      # Note that we are using the new :project_type field rather than extracting
      # it from :value. :project_type might not be present in unpublished projects.
      type: project[:project_type],
      publishedAt: project[:published_at],
    }
  end"
[s]StorageApps,get_published_project_data,Ret,"","{ channel: { [s]StorageApps#get_published_project_data arg: channel_id }, name: Object, thumbnailUrl: { [s]StorageApps#make_thumbnail_url_cacheable ret: ret }, type: { { [s]StorageApps#get_published_project_data arg: project }#[] call_ret: ret }, publishedAt: { { [s]StorageApps#get_published_project_data arg: project }#[] call_ret: ret } }","{ channel: Number, name: String, thumbnailUrl: String, type: String, publishedAt: DateTime }",P,Constraints,"def self.get_published_project_data(channel_id, project) ## MKCHANGE: changed arg positions
    project_value = JSON.parse(project[:value])
    {
      channel: channel_id,
      name: project_value['name'],
      thumbnailUrl: StorageApps.make_thumbnail_url_cacheable(project_value['thumbnailUrl']),
      # Note that we are using the new :project_type field rather than extracting
      # it from :value. :project_type might not be present in unpublished projects.
      type: project[:project_type],
      publishedAt: project[:published_at],
    }
  end"
[s]UserHelpers,initial,Arg,name,String,String,E,Heur: string_name,"def self.initial(name)
    return nil if name.blank?
    return name.strip[0].upcase
  end"
[s]UserHelpers,initial,Ret,"",String,String,E,Constraints,"def self.initial(name)
    return nil if name.blank?
    return name.strip[0].upcase
  end"
[s]UserHelpers,age_range_from_birthday,Arg,birthday,{ [s]UserHelpers#age_range_from_birthday arg: birthday },DateTime,N,,"def self.age_range_from_birthday(birthday)
    age = age_from_birthday(birthday)
    age_cutoff = AGE_CUTOFFS.find {|cutoff| cutoff <= age}
    age_cutoff ? ""#{age_cutoff}+"" : nil
  end"
[s]UserHelpers,age_range_from_birthday,Ret,"",String,String,E,Constraints,"def self.age_range_from_birthday(birthday)
    age = age_from_birthday(birthday)
    age_cutoff = AGE_CUTOFFS.find {|cutoff| cutoff <= age}
    age_cutoff ? ""#{age_cutoff}+"" : nil
  end"
Object,user_storage_ids_table,Ret,"","Table<{ id: Number, user_id: Number, __selected: nil, __last_joined: :user_storage_ids, __all_joined: :user_storage_ids, __orm: false }>","Table<{ id: Number, user_id: Number, __selected: nil, __last_joined: :user_storage_ids, __all_joined: :user_storage_ids, __orm: false }>",E,Constraints,"def user_storage_ids_table
  PEGASUS_DB[:user_storage_ids]
end"
Total # E:,119
Total # P:,19
Total # T:,15
Total # TS:,5
Total # N:,5
Total # return types:,74
Total # arg types:,78
Total # var types:,11
Total # individual types:,163
