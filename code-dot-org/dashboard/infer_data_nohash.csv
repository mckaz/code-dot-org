Class,Method/Variable,Inferred Type,Original Type,Source Code,Comments
Object,@user_permissions,Array<String>,Array<String>,
Object,@dashboard_user,"{ id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }","({ id: Number, email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, language: String, birthday: Date, parent_email: String, deleted_at: (DateTime or Time), hashed_email: String, properties: String, user_type: String, school: String, full_address: String, address: String, city: String, state: String, zip: String, lat: Number, lon: Number, total_lines: Number, secret_words: String, secret_picture_id: Number, secret_word_1_id: Number, secret_word_2_id: Number } or { id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number })",
Object,@request,([ nil?: () -> XXX ] and [ user_id: () -> XXX ]),,
Object,teaches_student?,"(Number, ?Number) -> (false or true)","(Number, ?Number) -> (false or true)","def teaches_student?(student_id, user_id = current_user_id)
  return false unless student_id && user_id
  DASHBOARD_DB[:sections].
      join(:followers, section_id: :sections__id).
      join(:users, id: :followers__student_user_id).
      where(sections__user_id: user_id, sections__deleted_at: nil).
      where(followers__student_user_id: student_id, followers__deleted_at: nil).
      where(users__deleted_at: nil).
      any?
end"
Object,owns_section?,(Number) -> (false or true),(Number) -> (false or true),"def owns_section?(section_id)
  return false unless section_id && current_user_id
  DASHBOARD_DB[:sections].where(id: section_id, user_id: current_user_id).any?
end"
Object,has_permission?,(XXX) -> (false or true),(String) -> (false or true),"def has_permission?(permission)
  return false unless current_user

  if @user_permissions.nil?
    @user_permissions = DASHBOARD_DB[:user_permissions].where(user_id: current_user_id).pluck(:permission)
  end
  @user_permissions.include? permission
end"
Object,current_user,"() -> { id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }",() -> User,"def current_user
  nil if current_user_id.nil?
  @dashboard_user ||= DASHBOARD_DB[:users][id: current_user_id]
end"
Object,get_user_sharing_disabled,(Number) -> (false or true),(Number) -> (false or true),"def get_user_sharing_disabled(user_id)
  user_properties = DASHBOARD_DB[:users].select(:properties).first(id: user_id)
  return false unless user_properties
  get_sharing_disabled_from_properties(user_properties[:properties])
end"
Object,current_user_id,() -> Number,() -> Number,"def current_user_id
  # @request is a Sinatra::Request < Rack::Request provided by Sinatra::Base
  @request.nil? ? nil : @request.user_id
end"
Object,get_sharing_disabled_from_properties,(String) -> (false or true),(String) -> (false or true),"def get_sharing_disabled_from_properties(properties)
  return false unless properties
  parsed_properties = JSON.parse(properties)
  !!parsed_properties[""sharing_disabled""]
end"
Object,storage_encrypt_channel_id,"(Number, Number) -> String","(Number, Number) -> String","def storage_encrypt_channel_id(storage_id, channel_id)
  storage_id = storage_id.to_i
  raise ArgumentError, ""`storage_id` must be an integer > 0"" unless storage_id > 0
  channel_id = channel_id.to_i
  raise ArgumentError, ""`channel_id` must be an integer > 0"" unless channel_id > 0
  Base64.urlsafe_encode64(storage_encrypt(""#{storage_id}:#{channel_id}"")).tr('=', '')
end"
Object,storage_decrypt_channel_id,"((String and [ length: () -> XXX ])) -> [XXX, XXX]","(Number) -> [Number, Number]","def storage_decrypt_channel_id(encrypted)
  raise ArgumentError, ""`encrypted` must be a string"" unless encrypted.is_a? String
  # pad to a multiple of 4 characters to make a valid base64 string.
  encrypted += '=' * ((4 - encrypted.length % 4) % 4)
  storage_id, channel_id = storage_decrypt(Base64.urlsafe_decode64(encrypted)).split(':').map(&:to_i)
  raise ArgumentError, ""`storage_id` must be an integer > 0"" unless storage_id > 0
  raise ArgumentError, ""`channel_id` must be an integer > 0"" unless channel_id > 0
  [storage_id, channel_id]
end"
Object,user_storage_ids_table,"() -> Table<{ id: Number, user_id: Number, __selected: nil, __last_joined: :user_storage_ids, __all_joined: :user_storage_ids, __orm: false }>",() -> ``Sequel::Mysql2::Database.gen_output_type(RDL::Type::SingletonType.new(:user_storage_ids))``,"def user_storage_ids_table
  PEGASUS_DB[:user_storage_ids]
end"
DashboardSection,@row,"({ id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true) } or { id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true), student_user_id: Number, section_id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number } or { id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true), studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number })","{ id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, deleted_at: (DateTime or Time), login_type: String, script_id: Number, login_method: Number, grade: String, admin_code: String, stage_extras: (false or true), pairing_allowed: (false or true), hidden: (false or true), course_id: Number, sharing_disabled: (false or true), student_user_id: Number, section_id: Number, email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, language: String, birthday: Date, parent_email: String, hashed_email: String, properties: String, user_type: String, school: String, full_address: String, address: String, city: String, state: String, zip: String, lat: Number, lon: Number, total_lines: Number, secret_words: String, secret_picture_id: Number, secret_word_1_id: Number, secret_word_2_id: Number }",
DashboardSection,@script,"{ id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), wrapup_video_id: Number, hidden: (false or true), user_id: Number, login_required: (false or true), properties: String, new_name: String, family_name: String }","{ id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), wrapup_video_id: Number, hidden: (false or true), user_id: Number, login_required: (false or true), properties: String, new_name: String, family_name: String }",
DashboardSection,@@script_cache,"([ []: (String) -> XXX ] and [ []=: (String, Array<XXX>) -> XXX ] and [ key?: (String) -> XXX ])","Hash<String, Array<{ id: Number, name: String, category: String, script_name: String, position: Number, category_priority: Number }>>",
DashboardSection,add_student,(([ []: (:admin) -> XXX ] and [ []: (:age) -> XXX ] and [ []: (:birthday) -> XXX ] and [ []: (:gender) -> XXX ] and [ []: (:id) -> XXX ] and [ []: (:name) -> XXX ] and [ []: (:sharing_disabled) -> XXX ])) -> Number,"({ name: String, age: Number, gender: String, birthday: Date, sharing_disabled: (false or true), id: Number, admin: (false or true) }) -> Number","def add_student(student)
    student_id = student[:id] || DashboardStudent.create(student)
    return nil unless student_id
    return nil if student[:admin]

    time_now = DateTime.now

    existing_follower = Dashboard.db[:followers].where(section_id: @row[:id], student_user_id: student_id).first
    if existing_follower
      Dashboard.db[:followers].where(id: existing_follower[:id]).update(deleted_at: nil, updated_at: time_now)
      return student_id
    end

    Dashboard.db[:followers].insert(
      {
        section_id: @row[:id],
        student_user_id: student_id,
        created_at: time_now,
        updated_at: time_now
      }
    )
    student_id
  end"
DashboardSection,add_students,([ map: () {(XXX) -> XXX} -> XXX ]) -> XXX,"(Array<{ name: String, age: Number, gender: String, birthday: Date, sharing_disabled: (false or true), id: Number, admin: (false or true) }>) -> Array<Number>","def add_students(students)
    student_ids = students.map {|i| add_student(i)}.compact
    DashboardUserScript.assign_script_to_users(@row[:script_id], student_ids) if @row[:script_id] && !student_ids.blank?
    return student_ids
  end"
DashboardSection,remove_student,(Number) -> (false or true),(Number) -> (false or true),"def remove_student(student_id)
    # BUGBUG: Need to detect ""sponsored"" accounts and disallow delete.

    rows_deleted = Dashboard.db[:followers].
      where(section_id: @row[:id], student_user_id: student_id, deleted_at: nil).
      update(deleted_at: DateTime.now)
    rows_deleted > 0
  end"
DashboardSection,script,"() -> { id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), wrapup_video_id: Number, hidden: (false or true), user_id: Number, login_required: (false or true), properties: String, new_name: String, family_name: String }","() -> { id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), wrapup_video_id: Number, hidden: (false or true), user_id: Number, login_required: (false or true), properties: String, new_name: String, family_name: String }","def script
    @script ||= Dashboard.db[:scripts].
      where(id: @row[:script_id]).
      select(:id, :name).
      first
  end"
DashboardSection,to_member_hash,"() -> { id: XXX, location: String, name: XXX, login_type: XXX, grade: XXX, code: XXX, stage_extras: XXX, pairing_allowed: XXX, hidden: XXX }","() -> { id: Number, location: String, name: String, login_type: String, grade: String, code: String, stage_extras: (false or true), pairing_allowed: (false or true), hidden: (false or true) }","def to_member_hash
    {
      id: @row[:id],
      location: ""/v2/sections/#{@row[:id]}"",
      name: @row[:name],
      login_type: @row[:login_type],
      grade: @row[:grade],
      code: @row[:code],
      stage_extras: @row[:stage_extras],
      pairing_allowed: @row[:pairing_allowed],
      hidden: @row[:hidden],
    }
  end"
DashboardSection,to_owner_hash,"() -> { id: XXX, location: String, name: XXX, login_type: XXX, grade: XXX, code: XXX, stage_extras: XXX, pairing_allowed: XXX, hidden: XXX, script: XXX, course_id: XXX, teachers: XXX, students: XXX, studentCount: XXX }","() -> { id: Number, location: String, name: String, login_type: String, grade: String, code: String, stage_extras: (false or true), pairing_allowed: (false or true), hidden: (false or true), script: { id: Number }, teachers: { id: Number, location: String }, students: {  }, studentCount: Number }","def to_owner_hash
    to_member_hash.merge(
      script: script,
      course_id: @row[:course_id],
      teachers: teachers,
      students: students,
      studentCount: students.count,
    )
  end"
DashboardSection,initialize,(XXX) -> self,(%any) -> self,"def initialize(row)
    @row = row
  end"
DashboardSection,member?,(Number) -> (false or true),(Number) -> (false or true),"def member?(user_id)
    return teacher?(user_id) || student?(user_id)
  end"
DashboardCourseExperiments,@@course_experiments,Array<String>,Array<String>,
DashboardCourseExperiments,@@course_experiment_map,"Hash<Number, Hash<String, true>>",%any,
DashboardCourseExperiments,@@course_experiment_map_last_update,Time,(Number or Time),
StorageApps,@storage_id,Number,Number,
StorageApps,@table,"Table<{ id: Number, storage_id: Number, value: String, updated_at: (DateTime or Time), updated_ip: String, state: String, created_at: (DateTime or Time), abuse_score: Number, project_type: String, published_at: (DateTime or Time), standalone: (false or true), remix_parent_id: Number, __selected: nil, __last_joined: :storage_apps, __all_joined: :storage_apps, __orm: false }>","Table<{ id: Number, storage_id: Number, value: String, updated_at: (DateTime or Time), updated_ip: String, state: String, created_at: (DateTime or Time), abuse_score: Number, project_type: String, published_at: (DateTime or Time), standalone: (false or true), remix_parent_id: Number, __selected: nil, __last_joined: :storage_apps, __all_joined: :storage_apps, __orm: false }>",
StorageApps,users_paired_on_level?,"(Number, Number, Number, Number) -> (false or true)","(Number, Number, Number, Number) -> (false or true)","def users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    channel_tokens_table = DASHBOARD_DB[:channel_tokens]
    level_id_row = channel_tokens_table.where(storage_app_id: storage_app_id, storage_id: owner_storage_id).first
    return false if level_id_row.nil?
    level_id = level_id_row[:level_id]

    user_levels_table = DASHBOARD_DB[:user_levels]
    owner_user_level_id = user_levels_table.select(:id).where(user_id: owner_user_id, level_id: level_id)
    current_user_level_id = user_levels_table.select(:id).where(user_id: current_user_id, level_id: level_id)

    paired_user_levels_table = DASHBOARD_DB[:paired_user_levels]
    paired_level_row = paired_user_levels_table.where(driver_user_level_id: owner_user_level_id, navigator_user_level_id: current_user_level_id).first
    return false if paired_level_row.nil?

    return true
  end"
StorageApps,initialize,(Number) -> self,(Number) -> self,"def initialize(storage_id)
    @storage_id = storage_id

    @table = PEGASUS_DB[:storage_apps]
  end"
StorageApps,create,"([ to_json: () -> XXX ], { ip: String, type: ?String, published_at: ?((DateTime or Time)), remix_parent_id: ?Number }) -> String","(String, { ip: String, type: ?String, published_at: ?DateTime, remix_parent_id: ?Number }) -> String","def create(value, ip:, type: nil, published_at: nil, remix_parent_id: nil)
    timestamp = DateTime.now
    row = {
      storage_id: @storage_id,
      value: value.to_json,
      created_at: timestamp,
      updated_at: timestamp,
      updated_ip: ip,
      abuse_score: 0,
      project_type: type,
      published_at: published_at,
      remix_parent_id: remix_parent_id,
    }
    row[:id] = @table.insert(row)

    storage_encrypt_channel_id(row[:storage_id], row[:id])
  end"
StorageApps,delete,((String and [ length: () -> XXX ])) -> true,(Number) -> true,"def delete(channel_id)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id

    delete_count = @table.where(id: id).update(state: 'deleted')
    raise NotFound, ""channel `#{channel_id}` not found"" if delete_count == 0

    # TODO: Delete all storage associated with this channel (e.g. properties and tables and assets)

    true
  end"
StorageApps,publish,"((String and [ length: () -> XXX ]), String, User) -> { channel: XXX, name: Object, thumbnailUrl: XXX, type: XXX, publishedAt: XXX, studentName: (XXX or XXX), studentAgeRange: (XXX or XXX) }","(Number, String, { name: String, birthday: DateTime }) -> { channel: Number, name: String, thumbnailUrl: String, type: String, publishedAt: DateTime, studentName: (String or { name: String, birthday: DateTime }), studentAgeRange: (String or { name: String, birthday: DateTime }) }","def publish(channel_id, type, user)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id
    row = {
      project_type: type,
      published_at: DateTime.now,
    }
    update_count = @table.where(id: id).exclude(state: 'deleted').update(row)
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    project = @table.where(id: id).first

    StorageApps.get_published_project_data(channel_id, project).merge(
      # For privacy reasons, include only the first initial of the student's name.
      studentName: user && UserHelpers.initial(user[:name]),
      studentAgeRange: user && UserHelpers.age_range_from_birthday(user[:birthday]),
    )
  end"
StorageApps,unpublish,((String and [ length: () -> XXX ])) -> nil,(Number) -> Number,"def unpublish(channel_id)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id
    row = {
      published_at: nil,
    }
    update_count = @table.where(id: id).exclude(state: 'deleted').update(row)
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0
  end"
StorageApps,get_abuse,((String and [ length: () -> XXX ])) -> XXX,(Number) -> Number,"def get_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    row[:abuse_score]
  end"
StorageApps,get_sharing_disabled,"((String and [ length: () -> XXX ]), Number) -> (false or true)","(Number, Number) -> (false or true)","def get_sharing_disabled(channel_id, current_user_id)
    owner_storage_id, storage_app_id = storage_decrypt_channel_id(channel_id)
    owner_user_id = user_storage_ids_table.where(id: owner_storage_id).first[:user_id]

    # Sharing of a project is not disabled for the project owner
    # or the teachers of the project owner
    # or if the current user paired with the owner
    if current_user_id == owner_user_id
      return false
    elsif teaches_student?(owner_user_id, current_user_id)
      return false
    elsif get_user_sharing_disabled(owner_user_id)
      !users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    else
      return false
    end

  # Default to sharing disabled if there is an error
  rescue ArgumentError, OpenSSL::Cipher::CipherError
    true
  end"
StorageApps,increment_abuse,((String and [ length: () -> XXX ])) -> XXX,(Number) -> Number,"def increment_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    new_score = row[:abuse_score] + (JSON.parse(row[:value])['frozen'] ? 0 : 10)

    update_count = @table.where(id: id).exclude(state: 'deleted').update({abuse_score: new_score})
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    new_score
  end"
StorageApps,reset_abuse,((String and [ length: () -> XXX ])) -> Number,(Number) -> Number,"def reset_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    update_count = @table.where(id: id).exclude(state: 'deleted').update({abuse_score: 0})
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    0
  end"
Dashboard::User,@row,"{ id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }","({ id: Number, email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, language: String, birthday: Date, parent_email: String, deleted_at: (DateTime or Time), hashed_email: String, properties: String, user_type: String, school: String, full_address: String, address: String, city: String, state: String, zip: String, lat: Number, lon: Number, total_lines: Number, secret_words: String, secret_picture_id: Number, secret_word_1_id: Number, secret_word_2_id: Number } or { id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number })",
Dashboard::User,get_followed_bys,(Array<Number>) -> Array<Number>,(Array<Number>) -> Array<Number>,"def get_followed_bys(other_user_ids)
      Dashboard.db[:sections].
        join(:followers, section_id: :sections__id).
        join(:users, id: :followers__student_user_id).
        where(sections__user_id: id, sections__deleted_at: nil).
        where(followers__student_user_id: other_user_ids, followers__deleted_at: nil).
        where(users__deleted_at: nil).
        select_map(:followers__student_user_id)
    end"
Dashboard::User,followed_by?,(Number) -> (false or true),(Number) -> (false or true),"def followed_by?(other_user_id)
      Dashboard.db[:sections].
        join(:followers, section_id: :sections__id).
        join(:users, id: :followers__student_user_id).
        where(sections__user_id: id, sections__deleted_at: nil).
        where(followers__student_user_id: other_user_id, followers__deleted_at: nil).
        where(users__deleted_at: nil).
        any?
    end"
Dashboard::User,owned_sections,() -> Array<{ id: Number }>,() -> Array<{ id: Number }>,"def owned_sections
      Dashboard.db[:sections].
        select(:id).where(user_id: id, deleted_at: nil).all
    end"
Dashboard::User,admin?,() -> (false or true),() -> (false or true),"def admin?
      !!@row[:admin]
    end"
Dashboard::User,has_permission?,((Array<String> or String)) -> (false or true),(String) -> (false or true),"def has_permission?(permission)
      permission = permission.to_s.strip.downcase
      case permission
        when 'admin' then admin?
        when 'teacher' then teacher?
        else !!Dashboard.db[:user_permissions][user_id: id, permission: permission]
      end
    end"
Dashboard::User,initialize,"({ id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }) -> self",(``fht(targs[0])``) -> self,"def initialize(user_row)
      @row = user_row
    end"
Dashboard::User,id,() -> Number,() -> Number,"def id
      @row[:id]
    end"
Dashboard::User,teacher?,() -> (false or true),() -> (false or true),"def teacher?
      @row[:user_type] == 'teacher'
    end"
[s]Dashboard,admin?,(Number) -> (false or true),(Number) -> (false or true),"def self.admin?(user_id)
    !!db[:users][id: user_id, admin: true]
  end"
[s]Dashboard::User,get_with_deleted,(Number) -> Dashboard::User,(Number) -> Dashboard::User,"def self.get_with_deleted(user_id)
      row = Dashboard.db[:users].where(id: user_id).first
      return nil unless row
      Dashboard::User.new(row)
    end"
[s]Dashboard::User,get,(Number) -> Dashboard::User,(Number) -> Dashboard::User,"def self.get(user_id)
      row = Dashboard.db[:users].where(id: user_id, deleted_at: nil).first
      return nil unless row
      Dashboard::User.new(row)
    end"
[s]DashboardStudent,fetch_user_students,"(Number) -> Array<{ id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true), student_user_id: Number, section_id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }>","(Number) -> Array<{ gender: String, user_type: String, hashed_email: String, secret_words: String, total_lines: Number, birthday: Date, email: String, username: String, name: String, id: Number }>","def self.fetch_user_students(user_id)
    Dashboard.db[:sections].
      join(:followers, section_id: :sections__id).
      join(:users, id: :followers__student_user_id).
      where(sections__user_id: user_id, sections__deleted_at: nil).
      where(followers__deleted_at: nil).
      where(users__deleted_at: nil).
      select(*fields).
      all
  end"
[s]DashboardStudent,fields,"() -> [:users__id___id, :users__name___name, :users__username___username, :users__email___email, :users__hashed_email___hashed_email, :users__user_type___user_type, :users__gender___gender, :users__birthday___birthday, :users__total_lines___total_lines, :users__secret_words___secret_words]","() -> [:users__id___id, :users__name___name, :users__username___username, :users__email___email, :users__hashed_email___hashed_email, :users__user_type___user_type, :users__gender___gender, :users__birthday___birthday, :users__total_lines___total_lines, :users__secret_words___secret_words]","def self.fields
    [
      :users__id___id,
      :users__name___name,
      :users__username___username,
      :users__email___email,
      :users__hashed_email___hashed_email,
      :users__user_type___user_type,
      :users__gender___gender,
      :users__birthday___birthday,
      :users__total_lines___total_lines,
      :users__secret_words___secret_words
    ]
  end"
[s]DashboardStudent,random_secrets,"() -> Hash<Symbol, (XXX or XXX)>","() -> { secret_picture_id: Number, secret_words: String }","def self.random_secrets
    {
      secret_picture_id: random_secret_picture_id,
      secret_words: random_secret_words
    }
  end"
[s]DashboardStudent,fetch_if_allowed,"(Number, Number) -> { id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number, path: String, age: XXX }","(Number, Number) -> { id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number, path: String, age: (Number or String) }","def self.fetch_if_allowed(id, dashboard_user_id)
    user = Dashboard::User.get(dashboard_user_id)
    return unless user && (user.followed_by?(id) || user.admin?)

    row = Dashboard.db[:users].
      where(users__id: id, users__deleted_at: nil).
      left_outer_join(:secret_pictures, id: :secret_picture_id).
      select(*fields,
        :secret_pictures__name___secret_picture_name,
        :secret_pictures__path___secret_picture_path,
      ).
      server(:default).
      first

    return if row.nil?

    row.merge(age: birthday_to_age(row[:birthday]))
  end"
[s]DashboardStudent,random_secret_picture_id,() -> %any,() -> Number,"def self.random_secret_picture_id
    SecureRandom.random_number(Dashboard.db[:secret_pictures].count) + 1
  end"
[s]DashboardStudent,update_if_allowed,"(([ []: (:age) -> XXX ] and [ []: (:gender) -> XXX ] and [ []: (:id) -> XXX ] and [ []: (:name) -> XXX ] and [ []: (:password) -> XXX ] and [ []: (:secrets) -> XXX ]), Number) -> { id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number, path: String, age: XXX }","(Number, { id: Number, name: String, age: Number, password: String, gender: String, secrets: String }) -> { id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number, path: String, age: (Number or String) }","def self.update_if_allowed(params, dashboard_user_id)
    user_to_update = Dashboard.db[:users].where(id: params[:id], deleted_at: nil)
    return if user_to_update.empty?
    return if Dashboard.db[:sections].
      join(:followers, section_id: :sections__id).
      where(sections__user_id: dashboard_user_id, sections__deleted_at: nil).
      where(followers__student_user_id: params[:id], followers__deleted_at: nil).
      empty?

    fields = {updated_at: DateTime.now}
    fields[:name] = params[:name] unless params[:name].nil_or_empty?
    fields[:encrypted_password] = encrypt_password(params[:password]) unless params[:password].nil_or_empty?
    fields[:gender] = params[:gender] if valid_gender?(params[:gender])
    fields[:birthday] = age_to_birthday(params[:age]) if age_to_birthday(params[:age])
    # TODO: Only save birthday if age changed.
    fields.merge!(random_secrets) if params[:secrets].to_s == 'reset'

    rows_updated = user_to_update.update(fields)
    return nil unless rows_updated > 0

    fetch_if_allowed(params[:id], dashboard_user_id)
  end"
[s]DashboardStudent,create,(([ []: (:age) -> XXX ] and [ []: (:birthday) -> XXX ] and [ []: (:gender) -> XXX ] and [ []: (:name) -> XXX ] and [ []: (:sharing_disabled) -> XXX ])) -> Number,"({ name: String, age: Number, gender: String, birthday: Date, sharing_disabled: (false or true), id: Number, admin: (false or true) }) -> Number","def self.create(params)
    name = !params[:name].to_s.empty? ? params[:name].to_s : 'New Student'
    gender = valid_gender?(params[:gender]) ? params[:gender] : nil
    birthday = age_to_birthday(params[:age]) ?
      age_to_birthday(params[:age]) : params[:birthday]
    sharing_disabled = !!params[:sharing_disabled]
    created_at = DateTime.now

    row = Dashboard.db[:users].insert(
      {
        name: name,
        user_type: 'student',
        provider: 'sponsored',
        gender: gender,
        properties: {sharing_disabled: sharing_disabled}.to_json,
        birthday: birthday,
        created_at: created_at,
        updated_at: created_at,
        username: UserHelpers.generate_username(Dashboard.db[:users], name)
      }.merge(random_secrets)
    )
    return nil unless row

    row
  end"
[s]DashboardStudent,random_secret_word,() -> String,() -> String,"def self.random_secret_word
    random_id = SecureRandom.random_number(Dashboard.db[:secret_words].count) + 1
    Dashboard.db[:secret_words].first(id: random_id)[:word]
  end"
[s]DashboardStudent,encrypt_password,(XXX) -> String,(String) -> String,"def self.encrypt_password(password)
    BCrypt::Password.create(""#{password}#{PEPPER}"", cost: STRETCHES).to_s
  end"
[s]DashboardStudent,valid_gender?,(XXX) -> (false or true),(String) -> (false or true),"def self.valid_gender?(gender)
    VALID_GENDERS.include?(gender)
  end"
[s]DashboardStudent,birthday_to_age,([ nil?: () -> XXX ]) -> (Number or String),(Date) -> (Number or String),"def self.birthday_to_age(birthday)
    return if birthday.nil?
    age = ((Date.today - birthday) / 365).to_i # TODO: Should this be 365.25?
    age = ""21+"" if age >= 21
    age
  end"
[s]DashboardStudent,age_to_birthday,(([ *: (Number) -> XXX ] and [ ==: (Number) -> XXX ] and [ to_i: () -> Number ])) -> %any,((Number or String)) -> Date,"def self.age_to_birthday(age)
    age = age.to_i
    return nil if age == 0
    Date.today - age * 365
  end"
[s]DashboardStudent,random_secret_words,() -> String,() -> String,"def self.random_secret_words
    ""#{random_secret_word} #{random_secret_word}""
  end"
[s]DashboardSection,fields,"() -> [:sections__id___id, :sections__name___name, :sections__code___code, :sections__stage_extras___stage_extras, :sections__pairing_allowed___pairing_allowed, :sections__login_type___login_type, :sections__sharing_disabled___sharing_disabled, :sections__hidden___hidden, :sections__grade___grade, :sections__script_id___script_id, :sections__course_id___course_id, :sections__user_id___teacher_id]","() -> [:sections__id___id, :sections__name___name, :sections__code___code, :sections__stage_extras___stage_extras, :sections__pairing_allowed___pairing_allowed, :sections__login_type___login_type, :sections__sharing_disabled___sharing_disabled, :sections__hidden___hidden, :sections__grade___grade, :sections__script_id___script_id, :sections__course_id___course_id, :sections__user_id___teacher_id]","def self.fields
    [
      :sections__id___id,
      :sections__name___name,
      :sections__code___code,
      :sections__stage_extras___stage_extras,
      :sections__pairing_allowed___pairing_allowed,
      :sections__login_type___login_type,
      :sections__sharing_disabled___sharing_disabled,
      :sections__hidden___hidden,
      :sections__grade___grade,
      :sections__script_id___script_id,
      :sections__course_id___course_id,
      :sections__user_id___teacher_id
    ]
  end"
[s]DashboardSection,update_if_owner,(([ []: (:course_id) -> XXX ] and [ []: (:grade) -> XXX ] and [ []: (:hidden) -> XXX ] and [ []: (:id) -> XXX ] and [ []: (:login_type) -> XXX ] and [ []: (:name) -> XXX ] and [ []: (:pairing_allowed) -> XXX ] and [ []: (:script) -> XXX ] and [ []: (:script_id) -> XXX ] and [ []: (:stage_extras) -> XXX ] and [ []: (:user) -> XXX ])) -> DashboardSection,"({ id: Number, user: ({ id: Number, email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, language: String, birthday: Date, parent_email: String, deleted_at: (DateTime or Time), hashed_email: String, properties: String, user_type: String, school: String, full_address: String, address: String, city: String, state: String, zip: String, lat: Number, lon: Number, total_lines: Number, secret_words: String, secret_picture_id: Number, secret_word_1_id: Number, secret_word_2_id: Number } or { id: Number, studio_person_id: Number, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Number, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Number, total_lines: Number, secret_picture_id: Number, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Number, invited_by_id: Number, invited_by_type: String, invitations_count: Number, terms_of_service_version: Number, urm: (false or true), races: String, primary_contact_info_id: Number }), name: String, login_type: String, stage_extras: (false or true), hidden: (false or true), course_id: Number, script: { id: Number }, grade: String, pairing_allowed: (false or true) }) -> DashboardSection","def self.update_if_owner(params)
    section_id = params[:id]
    return nil unless params[:user] && params[:user][:user_type] == 'teacher'
    user_id = params[:user][:id]

    fields = {updated_at: DateTime.now}
    fields[:name] = params[:name] unless params[:name].nil_or_empty?
    fields[:login_type] = params[:login_type] if valid_login_type?(params[:login_type])
    fields[:grade] = params[:grade] if valid_grade?(params[:grade])
    fields[:stage_extras] = params[:stage_extras]
    fields[:pairing_allowed] = params[:pairing_allowed]
    fields[:hidden] = params[:hidden] unless params[:hidden].nil?

    if params[:course_id] && valid_course_id?(params[:course_id])
      fields[:course_id] = params[:course_id].to_i
      # explicitly clear script_id (unless we're also passed in a valid script id
      # as a param
      fields[:script_id] = nil
    else
      # If no valid course_id provided, make sure we clear any existing course_id
      fields[:course_id] = nil
    end

    if params[:script] && valid_script_id?(params[:script][:id], user_id)
      fields[:script_id] = params[:script][:id].to_i
      DashboardUserScript.assign_script_to_section(fields[:script_id], section_id)
      DashboardUserScript.assign_script_to_user(fields[:script_id], user_id)
    elsif !params[:course_id] && !params[:script_id]
      # If a null course (no choice or decide later) is chosen, then update the course and script to be nil
      fields[:course_id] = nil
      fields[:script_id] = nil
    end

    rows_updated = Dashboard.db[:sections].
      where(id: section_id, user_id: user_id, deleted_at: nil).
      update(fields)
    return nil unless rows_updated > 0

    fetch_if_allowed(section_id, user_id)
  end"
[s]DashboardSection,fetch_if_allowed,"(Number, Number) -> DashboardSection","(Number, Number) -> DashboardSection","def self.fetch_if_allowed(id, user_id)
    # TODO: Allow caller to specify fields that they want because the
    # joins are getting a bit out of control (eg. you don't want to
    # get all the students passwords when we get the list of sections).

    return nil unless row = Dashboard.db[:sections].
      join(:users, id: :user_id).
      where(sections__id: id, sections__deleted_at: nil).
      select(*fields).
      first

    section = new(row)
    return section if section.member?(user_id) || Dashboard.admin?(user_id)
    nil
  end"
[s]DashboardSection,fetch_student_sections,"(Number) -> Array<{ id: XXX, location: String, name: XXX, login_type: XXX, grade: XXX, code: XXX, stage_extras: XXX, pairing_allowed: XXX, hidden: XXX }>","(Number) -> Array<{ id: Number, location: String, name: String, login_type: String, grade: String, code: String, stage_extras: (false or true), pairing_allowed: (false or true), hidden: (false or true) }>","def self.fetch_student_sections(student_id)
    return if student_id.nil?

    Dashboard.db[:sections].
      select(*fields).
      join(:followers, section_id: :id).
      join(:users, id: :student_user_id).
      where(student_user_id: student_id).
      where(sections__deleted_at: nil, followers__deleted_at: nil).
      map {|row| new(row).to_member_hash}
  end"
[s]DashboardSection,create,(([ []: (:course_id) -> XXX ] and [ []: (:grade) -> XXX ] and [ []: (:login_type) -> XXX ] and [ []: (:name) -> XXX ] and [ []: (:pairing_allowed) -> XXX ] and [ []: (:script) -> XXX ] and [ []: (:script_id) -> XXX ] and [ []: (:stage_extras) -> XXX ] and [ []: (:user) -> XXX ])) -> Number,"({ user: { user_type: String, id: Number }, name: String, login_type: String, grade: String, script: { id: Number }, script_id: Number, course_id: Number, stage_extras: (false or true), pairing_allowed: (false or true) }) -> Number","def self.create(params)
    return nil unless params[:user] && params[:user][:user_type] == 'teacher'

    name = !params[:name].to_s.empty? ? params[:name].to_s : 'New Section'
    login_type =
      params[:login_type].to_s == 'none' ? 'email' : params[:login_type].to_s
    login_type = 'word' unless valid_login_type?(login_type)
    grade = valid_grade?(params[:grade].to_s) ? params[:grade].to_s : nil
    script_id = params[:script] && valid_script_id?(params[:script][:id], params[:user][:id]) ?
      params[:script][:id].to_i : params[:script_id]
    course_id = params[:course_id] && valid_course_id?(params[:course_id]) ?
      params[:course_id].to_i : nil
    stage_extras = params[:stage_extras] ? params[:stage_extras] : false
    pairing_allowed = params[:pairing_allowed].nil? ? true : params[:pairing_allowed]
    created_at = DateTime.now

    row = nil
    tries = 0
    begin
      row = Dashboard.db[:sections].insert(
        {
          user_id: params[:user][:id],
          name: name,
          login_type: login_type,
          grade: grade,
          script_id: script_id,
          course_id: course_id,
          code: CodeGeneration.random_unique_code(length: 6),
          stage_extras: stage_extras,
          pairing_allowed: pairing_allowed,
          hidden: false,
          created_at: created_at,
          updated_at: created_at,
        }
      )
    rescue Sequel::UniqueConstraintViolation
      tries += 1
      retry if tries < 3
      raise
    end

    if params[:script] && valid_script_id?(params[:script][:id], params[:user][:id])
      DashboardUserScript.assign_script_to_user(params[:script][:id].to_i, params[:user][:id])
    end

    row
  end"
[s]DashboardSection,delete_if_owner,"(Number, Number) -> { id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true) }","(Number, Number) -> { id: Number, user_id: Number, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Number, course_id: Number, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true) }","def self.delete_if_owner(id, user_id)
    row = Dashboard.db[:sections].
      where(id: id, user_id: user_id, deleted_at: nil).
      first
    return nil unless row

    time_now = Time.now

    Dashboard.db.transaction do
      Dashboard.db[:followers].where(section_id: id, deleted_at: nil).
        update(deleted_at: time_now)
      Dashboard.db[:sections].where(id: id).update(deleted_at: time_now)
    end

    row
  end"
[s]DashboardSection,fetch_if_teacher,"(Number, Number) -> DashboardSection","(Number, Number) -> DashboardSection","def self.fetch_if_teacher(id, user_id)
    return nil unless row = Dashboard.db[:sections].
      select(*fields).
      where(sections__id: id, sections__user_id: user_id, sections__deleted_at: nil).
      first
    section = new(row)
    return section
  end"
[s]DashboardSection,valid_default_scripts,"(Number, XXX) -> (Array<XXX> or Hash<XXX, XXX>)","(Number, (false or true)) -> (Array<{ id: Number, name: String, category: String, script_name: String, position: Number, category_priority: Number }> or {  })","def self.valid_default_scripts(user_id, with_hidden)
    # some users can see all scripts, even those marked hidden
    script_cache_key = I18n.locale.to_s + (with_hidden ? ""-all"" : ""-valid"")

    # only do this query once because in prod we only change scripts
    # when deploying (technically this isn't true since we are in
    # pegasus and scripts are owned by dashboard...)
    if @@script_cache.key?(script_cache_key) && !rack_env?(:levelbuilder)
      return @@script_cache[script_cache_key]
    end

    # don't crash when loading environment before database has been created
    return {} unless (Dashboard.db[:scripts].count rescue nil)

    where_clause = with_hidden ? """" : ""hidden = 0""

    # cache result if we have to actually run the query
    scripts =
      Dashboard.db[:scripts].
        where(where_clause).
        select(:id, :name, :hidden).
        all.
        map {|script| assignable_info(script[:hidden], script)}
    @@script_cache[script_cache_key] = scripts unless rack_env?(:levelbuilder)
    scripts
  end"
[s]DashboardSection,valid_login_type?,(XXX) -> (false or true),(String) -> (false or true),"def self.valid_login_type?(login_type)
    valid_login_types.include? login_type
  end"
[s]DashboardSection,valid_grade?,(XXX) -> (false or true),(String) -> (false or true),"def self.valid_grade?(grade)
    valid_grades.include? grade
  end"
[s]DashboardSection,valid_course_id?,(Number) -> (false or true),(Number) -> (false or true),"def self.valid_course_id?(course_id)
    valid_courses.any? {|course| course[:id] == course_id.to_i}
  end"
[s]DashboardSection,valid_script_id?,"(Number, ?Number) -> (false or true)","(Number, ?Number) -> (false or true)","def self.valid_script_id?(script_id, user_id = nil)
    valid_scripts(user_id).any? {|script| script[:id] == script_id.to_i}
  end"
[s]DashboardSection,assignable_info,"(XXX, XXX) -> XXX","((false or true), { name: String, hidden: (false or true), id: Number }) -> { id: Number, name: String, category: String, script_name: String, position: Number, category_priority: Number }","def self.assignable_info(hidden, course_or_script) ## MKCHANGE: changed argument order
    info = ScriptConstants.assignable_info(course_or_script)
    info[:name] = I18n.t(""#{info[:name]}_name"", default: info[:name])
    info[:name] += "" *"" if hidden

    info[:category] = I18n.t(""#{info[:category]}_category_name"", default: info[:category])

    info
  end"
[s]DashboardUserScript,assign_script_to_user,"(Number, Number) -> Number","(Number, Number) -> Number","def self.assign_script_to_user(script_id, user_id)
    time_now = Time.now
    existing = Dashboard.db[:user_scripts].where(user_id: user_id, script_id: script_id).first
    if existing
      return if existing[:assigned_at]
      Dashboard.db[:user_scripts].where(user_id: user_id, script_id: script_id).update(
        updated_at: time_now,
        assigned_at: time_now
      )
    else
      Dashboard.db[:user_scripts].insert(
        user_id: user_id,
        script_id: script_id,
        created_at: time_now,
        updated_at: time_now,
        assigned_at: time_now
      )
    end
  end"
[s]DashboardUserScript,assign_script_to_users,"(Number, Array<Number>) -> Array<String>","(Number, Array<Number>) -> Array<String>","def self.assign_script_to_users(script_id, user_ids)
    # NOTE: This method could be more simply written by iterating over user_ids, calling
    # DashboardUserScript#assign_script_to_user for each. This (more complex) approach is used for
    # its better DB performance.
    return if user_ids.empty?

    time_now = Time.now
    all_existing = Dashboard.db[:user_scripts].where(user_id: user_ids, script_id: script_id)
    all_existing_user_ids = all_existing.map {|user_script| user_script[:user_id]}

    missing_assigned_at = []
    all_existing.each do |existing|
      missing_assigned_at << existing[:id] unless existing[:assigned_at]
    end
    Dashboard.db[:user_scripts].where(id: missing_assigned_at).update(
      updated_at: time_now,
      assigned_at: time_now
    )
    missing_user_scripts = RDL.type_cast(user_ids.select {|user_id| !all_existing_user_ids.include? user_id}, ""Array<Integer>"")
    return if missing_user_scripts.empty?
    Dashboard.db[:user_scripts].
      import(
        [:user_id, :script_id, :created_at, :updated_at, :assigned_at],
        RDL.type_cast(missing_user_scripts.zip(
          [script_id] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count
      ), ""Array<[Integer, Integer, Time, Time, Time]>"")
      )
  end"
[s]DashboardUserScript,assign_script_to_section,"(Number, Number) -> Array<String>","(Number, Number) -> Array<String>","def self.assign_script_to_section(script_id, section_id)
    student_user_ids = Dashboard.db[:followers].
      select(:student_user_id).
      where(section_id: section_id, deleted_at: nil).
      map {|f| f[:student_user_id]}
    DashboardUserScript.assign_script_to_users(script_id, student_user_ids)
  end"
[s]DashboardCourseExperiments,course_experiments,() -> Array<String>,() -> Array<String>,"def self.course_experiments
    @@course_experiments ||= Dashboard.db[:course_scripts].
      exclude(experiment_name: nil).
      all.
      map {|cs| cs[:experiment_name]}
  end"
[s]DashboardCourseExperiments,course_experiment_map,"() -> Hash<Number, Hash<String, true>>",() -> %any,"def self.course_experiment_map
    @@course_experiment_map = nil if Time.now > @@course_experiment_map_last_update + MAX_COURSE_EXPERIMENT_CACHE_SEC
    @@course_experiment_map ||= {}.tap do |map|
      @@course_experiment_map_last_update = Time.now
      Dashboard.db[:experiments].
        where(name: course_experiments, type: 'SingleUserExperiment').
        all.
        each do |row|
        user_id = row[:min_user_id]
        map[user_id] ||= {}
        map[user_id][row[:name]] = true
      end
    end
  end"
[s]UserHelpers,generate_username,"(([ respond_to?: (:connection) -> XXX ] and [ where: ({ username: (String or XXX) }) -> XXX ]), String) -> String","(%any, String) -> String","def self.generate_username(queryable, name)
    prefix = name.downcase.
      gsub(/[^#{USERNAME_ALLOWED_CHARACTERS.source}]+/, ' ')[0..USERNAME_MAX_LENGTH - 5].
      squish.
      tr(' ', '_')

    if prefix.empty? || prefix == ''
      prefix = 'coder' + rand(100000..999999).to_s
    end
    prefix = ""coder_#{prefix}"" if prefix.length < 5

    return prefix if queryable.where(username: prefix).limit(1).empty?

    # Throw random darts of increasing length (3 to 7 digits) to find an unused suffix.
    (2..6).each do |exponent|
      min_index = 10**exponent
      max_index = 10**(exponent + 1) - 1
      2.times do |_i|
        suffix = Random.rand(min_index..max_index)
        # Truncate generated username to max allowed length.
        username = ""#{prefix}#{suffix}""[0..USERNAME_MAX_LENGTH - 1]
        if queryable.where(username: username).limit(1).empty?
          return username
        end
      end
    end

    # Fallback to a range-scan query to find an available gap in the integer sequence.

    # Use CAST() and SUBSTRING() to parse the suffix as an integer.
    cast = lambda {|t| ""CAST(SUBSTRING(#{t}, #{prefix.length + 1}) as unsigned)""}

    query = <<SQL
SELECT #{cast.call('username')} + 1
  FROM users u
  WHERE username LIKE ""#{prefix}%""
    AND username RLIKE ""^#{prefix}[0-9]+$""
    AND NOT EXISTS (
      SELECT 1
      FROM users u2
      WHERE u2.username = CONCAT(""#{prefix}"", #{cast.call('u.username')} + 1)
    )
  LIMIT 1;
SQL
    # Execute raw query using either ActiveRecord or Sequel object.
    # MKCHANGE
    next_id = queryable.respond_to?(:connection) ?
      RDL.type_cast(queryable, ""ActiveRecord::ConnectionHandling"").connection.execute(query).first.first :
      RDL.type_cast(queryable, ""Sequel::Dataset"").db.fetch(query).first.values.first
    username = ""#{prefix}#{next_id}""
    raise ""generate_username overflow: #{username}"" if username.length > USERNAME_MAX_LENGTH
    username
  end"
[s]UserHelpers,initial,(String) -> String,(String) -> String,"def self.initial(name)
    return nil if name.blank?
    return name.strip[0].upcase
  end"
[s]UserHelpers,age_range_from_birthday,(XXX) -> String,(DateTime) -> String,"def self.age_range_from_birthday(birthday)
    age = age_from_birthday(birthday)
    age_cutoff = AGE_CUTOFFS.find {|cutoff| cutoff <= age}
    age_cutoff ? ""#{age_cutoff}+"" : nil
  end"
[s]StorageApps,get_published_project_data,"(XXX, ([ []: (:project_type) -> XXX ] and [ []: (:published_at) -> XXX ] and [ []: (:value) -> XXX ])) -> { channel: XXX, name: Object, thumbnailUrl: XXX, type: XXX, publishedAt: XXX }","(Number, { id: Number, storage_id: Number, value: String, updated_at: (DateTime or Time), updated_ip: String, state: String, created_at: (DateTime or Time), abuse_score: Number, project_type: String, published_at: (DateTime or Time), standalone: (false or true), remix_parent_id: Number }) -> { channel: Number, name: String, thumbnailUrl: String, type: String, publishedAt: DateTime }","def self.get_published_project_data(channel_id, project) ## MKCHANGE: changed arg positions
    project_value = JSON.parse(project[:value])
    {
      channel: channel_id,
      name: project_value['name'],
      thumbnailUrl: StorageApps.make_thumbnail_url_cacheable(project_value['thumbnailUrl']),
      # Note that we are using the new :project_type field rather than extracting
      # it from :value. :project_type might not be present in unpublished projects.
      type: project[:project_type],
      publishedAt: project[:published_at],
    }
  end"
