Class,Method,Inferred Type,Original Type,Source Code,Comments
[s]Dashboard,admin?,(Integer) -> (false or true),(Integer) -> (false or true),"def self.admin?(user_id)
    !!db[:users][id: user_id, admin: true]
  end",""
[s]Dashboard::User,get_with_deleted,(Integer) -> Dashboard::User,(Integer) -> Dashboard::User,"def self.get_with_deleted(user_id)
      row = Dashboard.db[:users].where(id: user_id).first
      return nil unless row
      Dashboard::User.new(row)
    end","# Retrieves the indicated user from the database, ignoring soft-deletes.
# @returns [User] for given user_id, or nil if not found in database
"
[s]Dashboard::User,get,(Integer) -> Dashboard::User,(Integer) -> Dashboard::User,"def self.get(user_id)
      row = Dashboard.db[:users].where(id: user_id, deleted_at: nil).first
      return nil unless row
      Dashboard::User.new(row)
    end","# Retrieves the indicated user from the database, respecting soft-deletes.
# @returns [User] for given user_id, or nil if not found in database
"
Dashboard::User,get_followed_bys,(Array<Integer>) -> Array<Integer>,(Array<Integer>) -> Array<Integer>,"def get_followed_bys(other_user_ids)
      Dashboard.db[:sections].
        join(:followers, section_id: :sections__id).
        join(:users, id: :followers__student_user_id).
        where(sections__user_id: id, sections__deleted_at: nil).
        where(followers__student_user_id: other_user_ids, followers__deleted_at: nil).
        where(users__deleted_at: nil).
        select_map(:followers__student_user_id)
    end","# @param other_user_ids [Array[Integer]] the user IDs to check.
# @return [Array[Integer]] the subset of other_user_ids that are followeds
#   of the user encapsulated by this class.
"
Dashboard::User,followed_by?,(Integer) -> (false or true),(Integer) -> (false or true),"def followed_by?(other_user_id)
      Dashboard.db[:sections].
        join(:followers, section_id: :sections__id).
        join(:users, id: :followers__student_user_id).
        where(sections__user_id: id, sections__deleted_at: nil).
        where(followers__student_user_id: other_user_id, followers__deleted_at: nil).
        where(users__deleted_at: nil).
        any?
    end","# @param other_user_id [Integer] the user ID to check.
# @return [Boolean] whether other_user_id is a followed of the user
#   encapsulated by this class.
"
Dashboard::User,owned_sections,() -> Array<{ id: Integer }>,() -> Array<{ id: Integer }>,"def owned_sections
      Dashboard.db[:sections].
        select(:id).where(user_id: id, deleted_at: nil).all
    end",""
Dashboard::User,admin?,() -> (false or true),() -> (false or true),"def admin?
      !!@row[:admin]
    end","# @returns [Boolean] true if user is an admin
"
Dashboard::User,has_permission?,((Array<String> or String)) -> (false or true),(String) -> (false or true),"def has_permission?(permission)
      permission = permission.to_s.strip.downcase
      case permission
        when 'admin' then admin?
        when 'teacher' then teacher?
        else !!Dashboard.db[:user_permissions][user_id: id, permission: permission]
      end
    end","# @param [String|Symbol] permission
# @returns [Boolean] true if user has the named permission
"
Object,teaches_student?,"(Integer, ?Integer) -> (false or true)","(Integer, ?Integer) -> (false or true)","def teaches_student?(student_id, user_id = current_user_id)
  return false unless student_id && user_id
  DASHBOARD_DB[:sections].
      join(:followers, section_id: :sections__id).
      join(:users, id: :followers__student_user_id).
      where(sections__user_id: user_id, sections__deleted_at: nil).
      where(followers__student_user_id: student_id, followers__deleted_at: nil).
      where(users__deleted_at: nil).
      any?
end","# @param [Integer] student_id
# @returns [Boolean] true iff the current user, or given user, is the teacher for the student of the given id
"
Object,owns_section?,(Integer) -> (false or true),(Integer) -> (false or true),"def owns_section?(section_id)
  return false unless section_id && current_user_id
  DASHBOARD_DB[:sections].where(id: section_id, user_id: current_user_id).any?
end","# @param [Integer] section_id
# @returns [Boolean] true iff the current user is the owner of the given section.
#          Note: NOT always true for admins.
"
Object,has_permission?,({ Object#has_permission? arg: permission }) -> (false or true),(String) -> (false or true),"def has_permission?(permission)
  return false unless current_user

  if @user_permissions.nil?
    @user_permissions = DASHBOARD_DB[:user_permissions].where(user_id: current_user_id).pluck(:permission)
  end
  @user_permissions.include? permission
end","# @param [String] permission - Name of the permission we're interested in
# @returns [Boolean] true if the current user has the specified dashboard permission
"
Object,current_user,"() -> { id: Integer, studio_person_id: Integer, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Integer, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Integer, total_lines: Integer, secret_picture_id: Integer, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Integer, invited_by_id: Integer, invited_by_type: String, invitations_count: Integer, terms_of_service_version: Integer, urm: (false or true), races: String, primary_contact_info_id: Integer }",() -> User,"def current_user
  nil if current_user_id.nil?
  @dashboard_user ||= DASHBOARD_DB[:users][id: current_user_id]
end","# @returns [User] the dashboard user associated with the current request.
"
Object,get_user_sharing_disabled,(Integer) -> (false or true),(Integer) -> (false or true),"def get_user_sharing_disabled(user_id)
  user_properties = DASHBOARD_DB[:users].select(:properties).first(id: user_id)
  return false unless user_properties
  get_sharing_disabled_from_properties(user_properties[:properties])
end","# Returns the sharing_disabled property of a user with a given user_id,
# always defaulting sharing to enabled.
"
[s]DashboardStudent,fetch_user_students,"(Integer) -> Array<{ id: Integer, user_id: Integer, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Integer, course_id: Integer, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true), student_user_id: Integer, section_id: Integer, studio_person_id: Integer, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Integer, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Integer, total_lines: Integer, secret_picture_id: Integer, active: (false or true), hashed_email: String, purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Integer, invited_by_id: Integer, invited_by_type: String, invitations_count: Integer, terms_of_service_version: Integer, urm: (false or true), races: String, primary_contact_info_id: Integer }>","(Integer) -> Array<{ gender: String, user_type: String, hashed_email: String, secret_words: String, total_lines: Integer, birthday: Date, email: String, username: String, name: String, id: Integer }>","def self.fetch_user_students(user_id)
    Dashboard.db[:sections].
      join(:followers, section_id: :sections__id).
      join(:users, id: :followers__student_user_id).
      where(sections__user_id: user_id, sections__deleted_at: nil).
      where(followers__deleted_at: nil).
      where(users__deleted_at: nil).
      select(*fields).
      all
  end","# Returns all users who are followers of the user with ID user_id.
"
[s]DashboardStudent,fields,() -> Array<(:users__birthday___birthday or :users__email___email or :users__gender___gender or :users__hashed_email___hashed_email or :users__id___id or :users__name___name or :users__secret_words___secret_words or :users__total_lines___total_lines or :users__user_type___user_type or :users__username___username)>,"() -> [:users__id___id, :users__name___name, :users__username___username, :users__email___email, :users__hashed_email___hashed_email, :users__user_type___user_type, :users__gender___gender, :users__birthday___birthday, :users__total_lines___total_lines, :users__secret_words___secret_words]","def self.fields
    [
      :users__id___id,
      :users__name___name,
      :users__username___username,
      :users__email___email,
      :users__hashed_email___hashed_email,
      :users__user_type___user_type,
      :users__gender___gender,
      :users__birthday___birthday,
      :users__total_lines___total_lines,
      :users__secret_words___secret_words
    ]
  end",""
[s]DashboardSection,fields,() -> Array<(:sections__code___code or :sections__course_id___course_id or :sections__grade___grade or :sections__hidden___hidden or :sections__id___id or :sections__login_type___login_type or :sections__name___name or :sections__pairing_allowed___pairing_allowed or :sections__script_id___script_id or :sections__sharing_disabled___sharing_disabled or :sections__stage_extras___stage_extras or :sections__user_id___teacher_id)>,"() -> [:sections__id___id, :sections__name___name, :sections__code___code, :sections__stage_extras___stage_extras, :sections__pairing_allowed___pairing_allowed, :sections__login_type___login_type, :sections__sharing_disabled___sharing_disabled, :sections__hidden___hidden, :sections__grade___grade, :sections__script_id___script_id, :sections__course_id___course_id, :sections__user_id___teacher_id]","def self.fields
    [
      :sections__id___id,
      :sections__name___name,
      :sections__code___code,
      :sections__stage_extras___stage_extras,
      :sections__pairing_allowed___pairing_allowed,
      :sections__login_type___login_type,
      :sections__sharing_disabled___sharing_disabled,
      :sections__hidden___hidden,
      :sections__grade___grade,
      :sections__script_id___script_id,
      :sections__course_id___course_id,
      :sections__user_id___teacher_id
    ]
  end",""
[s]DashboardStudent,random_secrets,"() -> Hash<Symbol, ({ [s]DashboardStudent#random_secret_picture_id ret: ret } or { [s]DashboardStudent#random_secret_words ret: ret })>","() -> { secret_picture_id: Integer, secret_words: String }","def self.random_secrets
    {
      secret_picture_id: random_secret_picture_id,
      secret_words: random_secret_words
    }
  end",""
[s]DashboardStudent,fetch_if_allowed,"(Integer, Integer) -> { id: Integer, studio_person_id: Integer, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Integer, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Integer, total_lines: Integer, secret_picture_id: Integer, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Integer, invited_by_id: Integer, invited_by_type: String, invitations_count: Integer, terms_of_service_version: Integer, urm: (false or true), races: String, primary_contact_info_id: Integer, path: String, age: { [s]DashboardStudent#birthday_to_age ret: ret } }","(Integer, Integer) -> { id: Integer, studio_person_id: Integer, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Integer, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Integer, total_lines: Integer, secret_picture_id: Integer, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Integer, invited_by_id: Integer, invited_by_type: String, invitations_count: Integer, terms_of_service_version: Integer, urm: (false or true), races: String, primary_contact_info_id: Integer, path: String, age: (Integer or String) }","def self.fetch_if_allowed(id, dashboard_user_id)
    user = Dashboard::User.get(dashboard_user_id)
    return unless user && (user.followed_by?(id) || user.admin?)

    row = Dashboard.db[:users].
      where(users__id: id, users__deleted_at: nil).
      left_outer_join(:secret_pictures, id: :secret_picture_id).
      select(*fields,
        :secret_pictures__name___secret_picture_name,
        :secret_pictures__path___secret_picture_path,
      ).
      server(:default).
      first

    return if row.nil?

    row.merge(age: birthday_to_age(row[:birthday]))
  end","# @param ids [Integer] the ID to fetch.
# @param dashboard_user_id [Integer] the ID of the user doing the fetching.
# @returns [Hash | nil] a hash (representing the requested user) or nil (if
#   the requested user does not exist or is accessible by dashboard_user_id).
"
[s]DashboardStudent,random_secret_picture_id,() -> Integer,() -> Integer,"def self.random_secret_picture_id
    SecureRandom.random_number(Dashboard.db[:secret_pictures].count) + 1
  end",""
[s]DashboardStudent,update_if_allowed,"({ id: (Array<Integer> or Integer), name: [ nil_or_empty?: () -> { { { [s]DashboardStudent#update_if_allowed arg: params }#[] ret: ret }#nil_or_empty? ret: ret } ], password: [ nil_or_empty?: () -> { { { [s]DashboardStudent#update_if_allowed arg: params }#[] ret: ret }#nil_or_empty? ret: ret } ], gender: { { [s]DashboardStudent#update_if_allowed arg: params }#[] ret: ret }, age: ([ *: (365) -> { { [s]DashboardStudent#age_to_birthday arg: age }#* ret: ret } ] and [ ==: (0) -> { { [s]DashboardStudent#age_to_birthday arg: age }#== ret: ret } ] and [ to_i: () -> Integer ]), secrets: [ to_s: () -> String ] }, Integer) -> { id: Integer, studio_person_id: Integer, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Integer, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Integer, total_lines: Integer, secret_picture_id: Integer, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Integer, invited_by_id: Integer, invited_by_type: String, invitations_count: Integer, terms_of_service_version: Integer, urm: (false or true), races: String, primary_contact_info_id: Integer, path: String, age: { [s]DashboardStudent#birthday_to_age ret: ret } }","(Integer, { id: Integer, name: String, age: Integer, password: String, gender: String, secrets: String }) -> { id: Integer, studio_person_id: Integer, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Integer, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Integer, total_lines: Integer, secret_picture_id: Integer, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Integer, invited_by_id: Integer, invited_by_type: String, invitations_count: Integer, terms_of_service_version: Integer, urm: (false or true), races: String, primary_contact_info_id: Integer, path: String, age: (Integer or String) }","def self.update_if_allowed(params, dashboard_user_id)
    user_to_update = Dashboard.db[:users].where(id: params[:id], deleted_at: nil)
    return if user_to_update.empty?
    return if Dashboard.db[:sections].
      join(:followers, section_id: :sections__id).
      where(sections__user_id: dashboard_user_id, sections__deleted_at: nil).
      where(followers__student_user_id: params[:id], followers__deleted_at: nil).
      empty?

    fields = {updated_at: DateTime.now}
    fields[:name] = params[:name] unless params[:name].nil_or_empty?
    fields[:encrypted_password] = encrypt_password(params[:password]) unless params[:password].nil_or_empty?
    fields[:gender] = params[:gender] if valid_gender?(params[:gender])
    fields[:birthday] = age_to_birthday(params[:age]) if age_to_birthday(params[:age])
    # TODO: Only save birthday if age changed.
    fields.merge!(random_secrets) if params[:secrets].to_s == 'reset'

    rows_updated = user_to_update.update(fields)
    return nil unless rows_updated > 0

    fetch_if_allowed(params[:id], dashboard_user_id)
  end",""
[s]DashboardSection,update_if_owner,"({ id: (Array<Integer> or Integer), user: { { [s]DashboardSection#update_if_owner arg: params }#[] ret: ret }, name: [ nil_or_empty?: () -> { { { [s]DashboardSection#update_if_owner arg: params }#[] ret: ret }#nil_or_empty? ret: ret } ], login_type: { { [s]DashboardSection#update_if_owner arg: params }#[] ret: ret }, grade: { { [s]DashboardSection#update_if_owner arg: params }#[] ret: ret }, stage_extras: (false or true), pairing_allowed: (false or true), hidden: [ nil?: () -> { { { [s]DashboardSection#update_if_owner arg: params }#[] ret: ret }#nil? ret: ret } ], course_id: { { [s]DashboardSection#update_if_owner arg: params }#[] ret: ret }, script: { { [s]DashboardSection#update_if_owner arg: params }#[] ret: ret }, script_id: [ !: () -> { { { [s]DashboardSection#update_if_owner arg: params }#[] ret: ret }#! ret: ret } ] }) -> DashboardSection","({ id: Integer, user: ({ id: Integer, email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Integer, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, language: String, birthday: Date, parent_email: String, deleted_at: (DateTime or Time), hashed_email: String, properties: String, user_type: String, school: String, full_address: String, address: String, city: String, state: String, zip: String, lat: Float, lon: Float, total_lines: Integer, secret_words: String, secret_picture_id: Integer, secret_word_1_id: Integer, secret_word_2_id: Integer } or { id: Integer, studio_person_id: Integer, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Integer, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Integer, total_lines: Integer, secret_picture_id: Integer, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Integer, invited_by_id: Integer, invited_by_type: String, invitations_count: Integer, terms_of_service_version: Integer, urm: (false or true), races: String, primary_contact_info_id: Integer }), name: String, login_type: String, stage_extras: (false or true), hidden: (false or true), course_id: Integer, script: { id: Integer }, grade: String, pairing_allowed: (false or true) }) -> DashboardSection","def self.update_if_owner(params)
    section_id = params[:id]
    return nil unless params[:user] && params[:user][:user_type] == 'teacher'
    user_id = params[:user][:id]

    fields = {updated_at: DateTime.now}
    fields[:name] = params[:name] unless params[:name].nil_or_empty?
    fields[:login_type] = params[:login_type] if valid_login_type?(params[:login_type])
    fields[:grade] = params[:grade] if valid_grade?(params[:grade])
    fields[:stage_extras] = params[:stage_extras]
    fields[:pairing_allowed] = params[:pairing_allowed]
    fields[:hidden] = params[:hidden] unless params[:hidden].nil?

    if params[:course_id] && valid_course_id?(params[:course_id])
      fields[:course_id] = params[:course_id].to_i
      # explicitly clear script_id (unless we're also passed in a valid script id
      # as a param
      fields[:script_id] = nil
    else
      # If no valid course_id provided, make sure we clear any existing course_id
      fields[:course_id] = nil
    end

    if params[:script] && valid_script_id?(params[:script][:id], user_id)
      fields[:script_id] = params[:script][:id].to_i
      DashboardUserScript.assign_script_to_section(fields[:script_id], section_id)
      DashboardUserScript.assign_script_to_user(fields[:script_id], user_id)
    elsif !params[:course_id] && !params[:script_id]
      # If a null course (no choice or decide later) is chosen, then update the course and script to be nil
      fields[:course_id] = nil
      fields[:script_id] = nil
    end

    rows_updated = Dashboard.db[:sections].
      where(id: section_id, user_id: user_id, deleted_at: nil).
      update(fields)
    return nil unless rows_updated > 0

    fetch_if_allowed(section_id, user_id)
  end",""
[s]DashboardUserScript,assign_script_to_user,"(Integer, Integer) -> Integer","(Integer, Integer) -> Integer","def self.assign_script_to_user(script_id, user_id)
    time_now = Time.now
    existing = Dashboard.db[:user_scripts].where(user_id: user_id, script_id: script_id).first
    if existing
      return if existing[:assigned_at]
      Dashboard.db[:user_scripts].where(user_id: user_id, script_id: script_id).update(
        updated_at: time_now,
        assigned_at: time_now
      )
    else
      Dashboard.db[:user_scripts].insert(
        user_id: user_id,
        script_id: script_id,
        created_at: time_now,
        updated_at: time_now,
        assigned_at: time_now
      )
    end
  end","# Assigns a script to the user via user_scripts, creating a new user_scripts object if necessary.
# The method noops if a user_scripts already exists with assigned_at set.
# @param script_id [Integer] The dashboard ID of the script.
# @param user_id [Integer] The dashboard ID of the user.
"
[s]DashboardUserScript,assign_script_to_users,"(Integer, Array<Integer>) -> Array<String>","(Integer, Array<Integer>) -> Array<String>","def self.assign_script_to_users(script_id, user_ids)
    # NOTE: This method could be more simply written by iterating over user_ids, calling
    # DashboardUserScript#assign_script_to_user for each. This (more complex) approach is used for
    # its better DB performance.
    return if user_ids.empty?

    time_now = Time.now
    all_existing = Dashboard.db[:user_scripts].where(user_id: user_ids, script_id: script_id)
    all_existing_user_ids = all_existing.map {|user_script| user_script[:user_id]}

    missing_assigned_at = []
    all_existing.each do |existing|
      missing_assigned_at << existing[:id] unless existing[:assigned_at]
    end
    Dashboard.db[:user_scripts].where(id: missing_assigned_at).update(
      updated_at: time_now,
      assigned_at: time_now
    )
    missing_user_scripts = user_ids.select {|user_id| !all_existing_user_ids.include? user_id}
    return if missing_user_scripts.empty?
    Dashboard.db[:user_scripts].
      import(
        [:user_id, :script_id, :created_at, :updated_at, :assigned_at],
        RDL.type_cast(missing_user_scripts.zip(
          [script_id] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count,
          [time_now] * missing_user_scripts.count
      ), ""Array<[Integer, Integer, Time, Time, Time]>"")
      )
  end","# Assigns a script to a set of users via user_scripts, creating new user_scripts objects if
# necessary. The method noops for those user_scripts that already exist with assigned_at set.
# WARNING: This method does not verify that the users exist (aren't deleted).
"
[s]DashboardUserScript,assign_script_to_section,"(Integer, (Array<Integer> or Integer)) -> Array<String>","(Integer, Integer) -> Array<String>","def self.assign_script_to_section(script_id, section_id)
    student_user_ids = Dashboard.db[:followers].
      select(:student_user_id).
      where(section_id: section_id, deleted_at: nil).
      map {|f| f[:student_user_id]}
    DashboardUserScript.assign_script_to_users(script_id, student_user_ids)
  end","# Assigns a script to all users enrolled in the section, creating a new user_scripts object if
# necessary. The method noops for those user_scripts that already exist with assigned_at set.
# WARNING: This method does not verify that the section and student_users exist (aren't deleted).
"
[s]DashboardSection,fetch_if_allowed,"((Array<Integer> or Integer), Integer) -> DashboardSection","(Integer, Integer) -> DashboardSection","def self.fetch_if_allowed(id, user_id)
    # TODO: Allow caller to specify fields that they want because the
    # joins are getting a bit out of control (eg. you don't want to
    # get all the students passwords when we get the list of sections).

    return nil unless row = Dashboard.db[:sections].
      join(:users, id: :user_id).
      where(sections__id: id, sections__deleted_at: nil).
      select(*fields).
      first

    section = new(row)
    return section if section.member?(user_id) || Dashboard.admin?(user_id)
    nil
  end",""
[s]DashboardSection,fetch_student_sections,"(Integer) -> Array<{ id: { { DashboardSection# var: @row }#[] ret: ret }, location: String, name: { { DashboardSection# var: @row }#[] ret: ret }, login_type: { { DashboardSection# var: @row }#[] ret: ret }, grade: { { DashboardSection# var: @row }#[] ret: ret }, code: { { DashboardSection# var: @row }#[] ret: ret }, stage_extras: { { DashboardSection# var: @row }#[] ret: ret }, pairing_allowed: { { DashboardSection# var: @row }#[] ret: ret }, hidden: { { DashboardSection# var: @row }#[] ret: ret } }>","(Integer) -> Array<{ id: Integer, location: String, name: String, login_type: String, grade: String, code: String, stage_extras: (false or true), pairing_allowed: (false or true), hidden: (false or true) }>","def self.fetch_student_sections(student_id)
    return if student_id.nil?

    Dashboard.db[:sections].
      select(*fields).
      join(:followers, section_id: :id).
      join(:users, id: :student_user_id).
      where(student_user_id: student_id).
      where(sections__deleted_at: nil, followers__deleted_at: nil).
      map {|row| new(row).to_member_hash}
  end",""
DashboardSection,add_student,"(([ []: (:birthday) -> { { [s]DashboardStudent#create arg: params }#[] ret: ret } ] and [ []: (:sharing_disabled) -> { { [s]DashboardStudent#create arg: params }#[] ret: ret } ] and { id: Integer, admin: { { DashboardSection#add_student arg: student }#[] ret: ret }, name: [ to_s: () -> String ], gender: { { [s]DashboardStudent#create arg: params }#[] ret: ret }, age: ([ *: (365) -> { { [s]DashboardStudent#age_to_birthday arg: age }#* ret: ret } ] and [ ==: (0) -> { { [s]DashboardStudent#age_to_birthday arg: age }#== ret: ret } ] and [ to_i: () -> Integer ]), birthday: { { [s]DashboardStudent#create arg: params }#[] ret: ret }, sharing_disabled: [ !: () -> { { { [s]DashboardStudent#create arg: params }#[] ret: ret }#! ret: ret } ] })) -> Integer","({ name: String, age: Integer, gender: String, birthday: Date, sharing_disabled: (false or true), id: Integer, admin: (false or true) }) -> Integer","def add_student(student)
    student_id = student[:id] || DashboardStudent.create(student)
    return nil unless student_id
    return nil if student[:admin]

    time_now = DateTime.now

    existing_follower = Dashboard.db[:followers].where(section_id: @row[:id], student_user_id: student_id).first
    if existing_follower
      Dashboard.db[:followers].where(id: existing_follower[:id]).update(deleted_at: nil, updated_at: time_now)
      return student_id
    end

    Dashboard.db[:followers].insert(
      {
        section_id: @row[:id],
        student_user_id: student_id,
        created_at: time_now,
        updated_at: time_now
      }
    )
    student_id
  end",""
DashboardSection,add_students,([ map: () {({ { DashboardSection#add_students arg: students }#map block_arg: i }) -> { { DashboardSection#add_students arg: students }#map block_ret: block_ret }} -> { { DashboardSection#add_students arg: students }#map ret: ret } ]) -> { DashboardSection#add_students ret: ret },"(Array<{ name: String, age: Integer, gender: String, birthday: Date, sharing_disabled: (false or true), id: Integer, admin: (false or true) }>) -> Array<Integer>","def add_students(students)
    student_ids = students.map {|i| add_student(i)}.compact
    DashboardUserScript.assign_script_to_users(@row[:script_id], student_ids) if @row[:script_id] && !student_ids.blank?
    return student_ids
  end",""
DashboardSection,remove_student,(Integer) -> (false or true),(Integer) -> (false or true),"def remove_student(student_id)
    # BUGBUG: Need to detect ""sponsored"" accounts and disallow delete.

    rows_deleted = Dashboard.db[:followers].
      where(section_id: @row[:id], student_user_id: student_id, deleted_at: nil).
      update(deleted_at: DateTime.now)
    rows_deleted > 0
  end","# @param student_id [Integer] The user ID of the student to unenroll.
# @return [Boolean] Whether the student's enrollment was removed.
"
[s]DashboardStudent,create,(([ []: (:age) -> { { [s]DashboardStudent#create arg: params }#[] ret: ret } ] and [ []: (:birthday) -> { { [s]DashboardStudent#create arg: params }#[] ret: ret } ] and [ []: (:gender) -> { { [s]DashboardStudent#create arg: params }#[] ret: ret } ] and [ []: (:name) -> { { [s]DashboardStudent#create arg: params }#[] ret: ret } ] and [ []: (:sharing_disabled) -> { { [s]DashboardStudent#create arg: params }#[] ret: ret } ])) -> Integer,"({ name: String, age: Integer, gender: String, birthday: Date, sharing_disabled: (false or true), id: Integer, admin: (false or true) }) -> Integer","def self.create(params)
    name = !params[:name].to_s.empty? ? params[:name].to_s : 'New Student'
    gender = valid_gender?(params[:gender]) ? params[:gender] : nil
    birthday = age_to_birthday(params[:age]) ?
      age_to_birthday(params[:age]) : params[:birthday]
    sharing_disabled = !!params[:sharing_disabled]
    created_at = DateTime.now

    row = Dashboard.db[:users].insert(
      {
        name: name,
        user_type: 'student',
        provider: 'sponsored',
        gender: gender,
        properties: {sharing_disabled: sharing_disabled}.to_json,
        birthday: birthday,
        created_at: created_at,
        updated_at: created_at,
        username: UserHelpers.generate_username(Dashboard.db[:users], name)
      }.merge(random_secrets)
    )
    return nil unless row

    row
  end",""
[s]DashboardCourseExperiments,course_experiments,() -> Array<String>,() -> Array<String>,"def self.course_experiments
    @@course_experiments ||= Dashboard.db[:course_scripts].
      exclude(experiment_name: nil).
      all.
      map {|cs| cs[:experiment_name]}
  end",""
[s]DashboardCourseExperiments,course_experiment_map,"() -> Hash<Integer, Hash<String, true>>",() -> %any,"def self.course_experiment_map
    @@course_experiment_map = nil if Time.now > @@course_experiment_map_last_update + MAX_COURSE_EXPERIMENT_CACHE_SEC
    @@course_experiment_map ||= {}.tap do |map|
      @@course_experiment_map_last_update = Time.now
      Dashboard.db[:experiments].
        where(name: course_experiments, type: 'SingleUserExperiment').
        all.
        each do |row|
        user_id = row[:min_user_id]
        map[user_id] ||= {}
        map[user_id][row[:name]] = true
      end
    end
  end",""
[s]DashboardSection,create,"(([ []: (:course_id) -> { { [s]DashboardSection#create arg: params }#[] ret: ret } ] and [ []: (:grade) -> { { [s]DashboardSection#create arg: params }#[] ret: ret } ] and [ []: (:login_type) -> { { [s]DashboardSection#create arg: params }#[] ret: ret } ] and [ []: (:name) -> { { [s]DashboardSection#create arg: params }#[] ret: ret } ] and [ []: (:script) -> { { [s]DashboardSection#create arg: params }#[] ret: ret } ] and [ []: (:script_id) -> { { [s]DashboardSection#create arg: params }#[] ret: ret } ] and [ []: (:stage_extras) -> { { [s]DashboardSection#create arg: params }#[] ret: ret } ] and { user: { { [s]DashboardSection#create arg: params }#[] ret: ret }, name: [ to_s: () -> String ], login_type: [ to_s: () -> String ], grade: [ to_s: () -> String ], script: { { [s]DashboardSection#create arg: params }#[] ret: ret }, script_id: Integer, course_id: { { [s]DashboardSection#create arg: params }#[] ret: ret }, stage_extras: { { [s]DashboardSection#create arg: params }#[] ret: ret }, pairing_allowed: [ nil?: () -> { { { [s]DashboardSection#create arg: params }#[] ret: ret }#nil? ret: ret } ] })) -> Integer","({ user: { user_type: String, id: Integer }, name: String, login_type: String, grade: String, script: { id: Integer }, script_id: Integer, course_id: Integer, stage_extras: (false or true), pairing_allowed: (false or true) }) -> Integer","def self.create(params)
    return nil unless params[:user] && params[:user][:user_type] == 'teacher'

    name = !params[:name].to_s.empty? ? params[:name].to_s : 'New Section'
    login_type =
      params[:login_type].to_s == 'none' ? 'email' : params[:login_type].to_s
    login_type = 'word' unless valid_login_type?(login_type)
    grade = valid_grade?(params[:grade].to_s) ? params[:grade].to_s : nil
    script_id = params[:script] && valid_script_id?(params[:script][:id], params[:user][:id]) ?
      params[:script][:id].to_i : params[:script_id]
    course_id = params[:course_id] && valid_course_id?(params[:course_id]) ?
      params[:course_id].to_i : nil
    stage_extras = params[:stage_extras] ? params[:stage_extras] : false
    pairing_allowed = params[:pairing_allowed].nil? ? true : params[:pairing_allowed]
    created_at = DateTime.now

    row = nil
    tries = 0
    begin
      row = Dashboard.db[:sections].insert(
        {
          user_id: params[:user][:id],
          name: name,
          login_type: login_type,
          grade: grade,
          script_id: script_id,
          course_id: course_id,
          code: CodeGeneration.random_unique_code(length: 6),
          stage_extras: stage_extras,
          pairing_allowed: pairing_allowed,
          hidden: false,
          created_at: created_at,
          updated_at: created_at,
        }
      )
    rescue Sequel::UniqueConstraintViolation
      tries += 1
      retry if tries < 3
      raise
    end

    if params[:script] && valid_script_id?(params[:script][:id], params[:user][:id])
      DashboardUserScript.assign_script_to_user(params[:script][:id].to_i, params[:user][:id])
    end

    row
  end",""
[s]DashboardSection,delete_if_owner,"(Integer, Integer) -> { id: Integer, user_id: Integer, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Integer, course_id: Integer, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true) }","(Integer, Integer) -> { id: Integer, user_id: Integer, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Integer, course_id: Integer, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true) }","def self.delete_if_owner(id, user_id)
    row = Dashboard.db[:sections].
      where(id: id, user_id: user_id, deleted_at: nil).
      first
    return nil unless row

    time_now = Time.now

    Dashboard.db.transaction do
      Dashboard.db[:followers].where(section_id: id, deleted_at: nil).
        update(deleted_at: time_now)
      Dashboard.db[:sections].where(id: id).update(deleted_at: time_now)
    end

    row
  end","# Soft deletes both the section with ID `id` and all associated followers
# relationships.
"
[s]DashboardSection,fetch_if_teacher,"(Integer, Integer) -> DashboardSection","(Integer, Integer) -> DashboardSection","def self.fetch_if_teacher(id, user_id)
    return nil unless row = Dashboard.db[:sections].
      select(*fields).
      where(sections__id: id, sections__user_id: user_id, sections__deleted_at: nil).
      first
    section = new(row)
    return section
  end",""
DashboardSection,script,"() -> { id: Integer, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), wrapup_video_id: Integer, hidden: (false or true), user_id: Integer, login_required: (false or true), properties: String, new_name: String, family_name: String }","() -> { id: Integer, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), wrapup_video_id: Integer, hidden: (false or true), user_id: Integer, login_required: (false or true), properties: String, new_name: String, family_name: String }","def script
    @script ||= Dashboard.db[:scripts].
      where(id: @row[:script_id]).
      select(:id, :name).
      first
  end",""
[s]DashboardStudent,random_secret_word,() -> String,() -> String,"def self.random_secret_word
    random_id = SecureRandom.random_number(Dashboard.db[:secret_words].count) + 1
    Dashboard.db[:secret_words].first(id: random_id)[:word]
  end",""
[s]DashboardSection,valid_default_scripts,"(Integer, { [s]DashboardSection#valid_default_scripts arg: with_hidden }) -> (Array<{ [s]DashboardSection#assignable_info ret: ret }> or {  })","(Integer, (false or true)) -> (Array<{ id: Integer, name: String, category: String, script_name: String, position: Integer, category_priority: Integer }> or {  })","def self.valid_default_scripts(user_id, with_hidden)
    # some users can see all scripts, even those marked hidden
    script_cache_key = I18n.locale.to_s + (with_hidden ? ""-all"" : ""-valid"")

    # only do this query once because in prod we only change scripts
    # when deploying (technically this isn't true since we are in
    # pegasus and scripts are owned by dashboard...)
    if @@script_cache.key?(script_cache_key) && !rack_env?(:levelbuilder)
      return @@script_cache[script_cache_key]
    end

    # don't crash when loading environment before database has been created
    return {} unless (Dashboard.db[:scripts].count rescue nil)

    where_clause = with_hidden ? """" : ""hidden = 0""

    # cache result if we have to actually run the query
    scripts =
      Dashboard.db[:scripts].
        where(where_clause).
        select(:id, :name, :hidden).
        all.
        map {|script| assignable_info(script[:hidden], script)}
    @@script_cache[script_cache_key] = scripts unless rack_env?(:levelbuilder)
    scripts
  end",""
StorageApps,users_paired_on_level?,"(Integer, Integer, Integer, Integer) -> (false or true)","(Integer, Integer, Integer, Integer) -> (false or true)","def users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    channel_tokens_table = DASHBOARD_DB[:channel_tokens]
    level_id_row = channel_tokens_table.where(storage_app_id: storage_app_id, storage_id: owner_storage_id).first
    return false if level_id_row.nil?
    level_id = level_id_row[:level_id]

    user_levels_table = DASHBOARD_DB[:user_levels]
    owner_user_level_id = user_levels_table.select(:id).where(user_id: owner_user_id, level_id: level_id)
    current_user_level_id = user_levels_table.select(:id).where(user_id: current_user_id, level_id: level_id)

    paired_user_levels_table = DASHBOARD_DB[:paired_user_levels]
    paired_level_row = paired_user_levels_table.where(driver_user_level_id: owner_user_level_id, navigator_user_level_id: current_user_level_id).first
    return false if paired_level_row.nil?

    return true
  end",""
StorageApps,initialize,(Integer) -> self,(Integer) -> self,"def initialize(storage_id)
    @storage_id = storage_id

    @table = PEGASUS_DB[:storage_apps]
  end",""
StorageApps,create,"([ to_json: () -> { { StorageApps#create arg: value }#to_json ret: ret } ], { ip: String, type: ?String, published_at: ?((DateTime or Time)), remix_parent_id: ?Integer }) -> String","(String, { ip: String, type: ?String, published_at: ?DateTime, remix_parent_id: ?Integer }) -> String","def create(value, ip:, type: nil, published_at: nil, remix_parent_id: nil)
    timestamp = DateTime.now
    row = {
      storage_id: @storage_id,
      value: value.to_json,
      created_at: timestamp,
      updated_at: timestamp,
      updated_ip: ip,
      abuse_score: 0,
      project_type: type,
      published_at: published_at,
      remix_parent_id: remix_parent_id,
    }
    row[:id] = @table.insert(row)

    storage_encrypt_channel_id(row[:storage_id], row[:id])
  end",""
StorageApps,delete,(String) -> true,(Integer) -> true,"def delete(channel_id)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id

    delete_count = @table.where(id: id).update(state: 'deleted')
    raise NotFound, ""channel `#{channel_id}` not found"" if delete_count == 0

    # TODO: Delete all storage associated with this channel (e.g. properties and tables and assets)

    true
  end",""
StorageApps,publish,"(String, String, User) -> { channel: { [s]StorageApps#get_published_project_data arg: channel_id }, name: Object, thumbnailUrl: { [s]StorageApps#make_thumbnail_url_cacheable ret: ret }, type: { { [s]StorageApps#get_published_project_data arg: project }#[] ret: ret }, publishedAt: { { [s]StorageApps#get_published_project_data arg: project }#[] ret: ret }, studentName: { [s]UserHelpers#initial ret: ret }, studentAgeRange: { [s]UserHelpers#age_range_from_birthday ret: ret } }","(Integer, String, { name: String, birthday: DateTime }) -> { channel: Integer, name: String, thumbnailUrl: String, type: String, publishedAt: DateTime, studentName: (String or { name: String, birthday: DateTime }), studentAgeRange: (String or { name: String, birthday: DateTime }) }","def publish(channel_id, type, user)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id
    row = {
      project_type: type,
      published_at: DateTime.now,
    }
    update_count = @table.where(id: id).exclude(state: 'deleted').update(row)
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    project = @table.where(id: id).first

    StorageApps.get_published_project_data(channel_id, project).merge(
      # For privacy reasons, include only the first initial of the student's name.
      studentName: user && UserHelpers.initial(user[:name]),
      studentAgeRange: user && UserHelpers.age_range_from_birthday(user[:birthday]),
    )
  end",""
StorageApps,unpublish,(String) -> nil,(Integer) -> Integer,"def unpublish(channel_id)
    owner, id = storage_decrypt_channel_id(channel_id)
    raise NotFound, ""channel `#{channel_id}` not found in your storage"" unless owner == @storage_id
    row = {
      published_at: nil,
    }
    update_count = @table.where(id: id).exclude(state: 'deleted').update(row)
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0
  end",""
StorageApps,get_abuse,(String) -> { StorageApps#get_abuse ret: ret },(Integer) -> Integer,"def get_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    row[:abuse_score]
  end",""
StorageApps,get_sharing_disabled,"(String, Integer) -> (false or true)","(Integer, Integer) -> (false or true)","def get_sharing_disabled(channel_id, current_user_id)
    owner_storage_id, storage_app_id = storage_decrypt_channel_id(channel_id)
    owner_user_id = user_storage_ids_table.where(id: owner_storage_id).first[:user_id]

    # Sharing of a project is not disabled for the project owner
    # or the teachers of the project owner
    # or if the current user paired with the owner
    if current_user_id == owner_user_id
      return false
    elsif teaches_student?(owner_user_id, current_user_id)
      return false
    elsif get_user_sharing_disabled(owner_user_id)
      !users_paired_on_level?(storage_app_id, current_user_id, owner_user_id, owner_storage_id)
    else
      return false
    end

  # Default to sharing disabled if there is an error
  rescue ArgumentError, OpenSSL::Cipher::CipherError
    true
  end","# Determine if the current user can view the project
"
StorageApps,increment_abuse,(String) -> { StorageApps#increment_abuse ret: ret },(Integer) -> Integer,"def increment_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    new_score = row[:abuse_score] + (JSON.parse(row[:value])['frozen'] ? 0 : 10)

    update_count = @table.where(id: id).exclude(state: 'deleted').update({abuse_score: new_score})
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    new_score
  end",""
StorageApps,reset_abuse,(String) -> 0,(Integer) -> Integer,"def reset_abuse(channel_id)
    _owner, id = storage_decrypt_channel_id(channel_id)

    row = @table.where(id: id).exclude(state: 'deleted').first
    raise NotFound, ""channel `#{channel_id}` not found"" unless row

    update_count = @table.where(id: id).exclude(state: 'deleted').update({abuse_score: 0})
    raise NotFound, ""channel `#{channel_id}` not found"" if update_count == 0

    0
  end",""
Dashboard::User,initialize,"(([ []: (:user_type) -> { { Dashboard::User# var: @row }#[] ret: ret } ] and { id: Integer, studio_person_id: Integer, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Integer, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), username: String, provider: String, uid: String, admin: (false or true), gender: String, name: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Integer, total_lines: Integer, secret_picture_id: Integer, active: (false or true), hashed_email: String, deleted_at: (DateTime or Time), purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Integer, invited_by_id: Integer, invited_by_type: String, invitations_count: Integer, terms_of_service_version: Integer, urm: (false or true), races: String, primary_contact_info_id: Integer })) -> self",(``fht(targs[0])``) -> self,"def initialize(user_row)
      @row = user_row
    end","# Wrap dashboard user row in this helper object.
# You can use this, but it's preferred that clients call User.get(user_id).
"
Dashboard::User,id,() -> Integer,() -> Integer,"def id
      @row[:id]
    end",""
Dashboard::User,teacher?,() -> (false or true),() -> (false or true),"def teacher?
      @row[:user_type] == 'teacher'
    end","# @returns [Boolean] true if user is a teacher
"
Object,current_user_id,() -> Integer,() -> Integer,"def current_user_id
  # @request is a Sinatra::Request < Rack::Request provided by Sinatra::Base
  @request.nil? ? nil : @request.user_id
end","#
# Utility methods that help middleware access dashboard authentication and
# permissions information.
#
# Note: This file should be loaded in the context of a Sinatra application;
#       see net_sim_api.rb for an example of this.
#
# @returns [Integer] the user_id associated with the current request
"
[s]DashboardStudent,encrypt_password,({ [s]DashboardStudent#encrypt_password arg: password }) -> String,(String) -> String,"def self.encrypt_password(password)
    BCrypt::Password.create(""#{password}#{PEPPER}"", cost: STRETCHES).to_s
  end",""
[s]DashboardStudent,valid_gender?,({ [s]DashboardStudent#valid_gender? arg: gender }) -> (false or true),(String) -> (false or true),"def self.valid_gender?(gender)
    VALID_GENDERS.include?(gender)
  end",""
[s]DashboardStudent,birthday_to_age,([ nil?: () -> { { [s]DashboardStudent#birthday_to_age arg: birthday }#nil? ret: ret } ]) -> ('21+' or Integer),(Date) -> (Integer or String),"def self.birthday_to_age(birthday)
    return if birthday.nil?
    age = ((Date.today - birthday) / 365).to_i # TODO: Should this be 365.25?
    age = ""21+"" if age >= 21
    age
  end",""
[s]DashboardStudent,age_to_birthday,(([ *: (365) -> { { [s]DashboardStudent#age_to_birthday arg: age }#* ret: ret } ] and [ ==: (0) -> { { [s]DashboardStudent#age_to_birthday arg: age }#== ret: ret } ] and [ to_i: () -> Integer ])) -> nil,((Integer or String)) -> Date,"def self.age_to_birthday(age)
    age = age.to_i
    return nil if age == 0
    Date.today - age * 365
  end",""
[s]DashboardStudent,random_secret_words,() -> %any,() -> String,"def self.random_secret_words
    ""#{random_secret_word} #{random_secret_word}""
  end",""
[s]DashboardSection,valid_login_type?,({ [s]DashboardSection#valid_login_type? arg: login_type }) -> (false or true),(String) -> (false or true),"def self.valid_login_type?(login_type)
    valid_login_types.include? login_type
  end",""
[s]DashboardSection,valid_grade?,({ [s]DashboardSection#valid_grade? arg: grade }) -> (false or true),(String) -> (false or true),"def self.valid_grade?(grade)
    valid_grades.include? grade
  end",""
[s]DashboardSection,valid_course_id?,(Integer) -> (false or true),(Integer) -> (false or true),"def self.valid_course_id?(course_id)
    valid_courses.any? {|course| course[:id] == course_id.to_i}
  end","# @param script_id [String] id of the course we're checking the validity of
# @return [Boolean] Wheter or not the course_id is a valid course ID.
"
[s]DashboardSection,valid_script_id?,"(Integer, ?Integer) -> (false or true)","(Integer, ?Integer) -> (false or true)","def self.valid_script_id?(script_id, user_id = nil)
    valid_scripts(user_id).any? {|script| script[:id] == script_id.to_i}
  end","# @param script_id [String] id of the script we're checking the validity of
# @param user_id [Integer] id of the user we are checking for, in case they
#   are in any course experiments, which would give them different valid scripts
# @return [Boolean] Whether or not script_id is a valid script ID.
"
DashboardSection,to_member_hash,"() -> { id: { { DashboardSection# var: @row }#[] ret: ret }, location: String, name: { { DashboardSection# var: @row }#[] ret: ret }, login_type: { { DashboardSection# var: @row }#[] ret: ret }, grade: { { DashboardSection# var: @row }#[] ret: ret }, code: { { DashboardSection# var: @row }#[] ret: ret }, stage_extras: { { DashboardSection# var: @row }#[] ret: ret }, pairing_allowed: { { DashboardSection# var: @row }#[] ret: ret }, hidden: { { DashboardSection# var: @row }#[] ret: ret } }","() -> { id: Integer, location: String, name: String, login_type: String, grade: String, code: String, stage_extras: (false or true), pairing_allowed: (false or true), hidden: (false or true) }","def to_member_hash
    {
      id: @row[:id],
      location: ""/v2/sections/#{@row[:id]}"",
      name: @row[:name],
      login_type: @row[:login_type],
      grade: @row[:grade],
      code: @row[:code],
      stage_extras: @row[:stage_extras],
      pairing_allowed: @row[:pairing_allowed],
      hidden: @row[:hidden],
    }
  end",""
DashboardSection,to_owner_hash,"() -> { id: { { DashboardSection# var: @row }#[] ret: ret }, location: String, name: { { DashboardSection# var: @row }#[] ret: ret }, login_type: { { DashboardSection# var: @row }#[] ret: ret }, grade: { { DashboardSection# var: @row }#[] ret: ret }, code: { { DashboardSection# var: @row }#[] ret: ret }, stage_extras: { { DashboardSection# var: @row }#[] ret: ret }, pairing_allowed: { { DashboardSection# var: @row }#[] ret: ret }, hidden: { { DashboardSection# var: @row }#[] ret: ret }, script: { DashboardSection#script ret: ret }, course_id: { { DashboardSection# var: @row }#[] ret: ret }, teachers: { DashboardSection#teachers ret: ret }, students: { DashboardSection#students ret: ret }, studentCount: { { DashboardSection#students ret: ret }#count ret: ret } }","() -> { id: Integer, location: String, name: String, login_type: String, grade: String, code: String, stage_extras: (false or true), pairing_allowed: (false or true), hidden: (false or true), script: { id: Integer }, teachers: { id: Integer, location: String }, students: {  }, studentCount: Integer }","def to_owner_hash
    to_member_hash.merge(
      script: script,
      course_id: @row[:course_id],
      teachers: teachers,
      students: students,
      studentCount: students.count,
    )
  end",""
DashboardSection,initialize,"(({ id: Integer, user_id: Integer, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Integer, course_id: Integer, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true) } or { id: Integer, user_id: Integer, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Integer, course_id: Integer, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true), student_user_id: Integer, section_id: Integer, studio_person_id: Integer, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Integer, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Integer, total_lines: Integer, secret_picture_id: Integer, active: (false or true), hashed_email: String, purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Integer, invited_by_id: Integer, invited_by_type: String, invitations_count: Integer, terms_of_service_version: Integer, urm: (false or true), races: String, primary_contact_info_id: Integer } or { id: Integer, user_id: Integer, name: String, created_at: (DateTime or Time), updated_at: (DateTime or Time), code: String, script_id: Integer, course_id: Integer, grade: String, login_type: String, deleted_at: (DateTime or Time), stage_extras: (false or true), section_type: String, first_activity_at: (DateTime or Time), pairing_allowed: (false or true), sharing_disabled: (false or true), hidden: (false or true), studio_person_id: Integer, email: String, parent_email: String, encrypted_password: String, reset_password_token: String, reset_password_sent_at: (DateTime or Time), remember_created_at: (DateTime or Time), sign_in_count: Integer, current_sign_in_at: (DateTime or Time), last_sign_in_at: (DateTime or Time), current_sign_in_ip: String, last_sign_in_ip: String, username: String, provider: String, uid: String, admin: (false or true), gender: String, locale: String, birthday: Date, user_type: String, school: String, full_address: String, school_info_id: Integer, total_lines: Integer, secret_picture_id: Integer, active: (false or true), hashed_email: String, purged_at: (DateTime or Time), secret_words: String, properties: String, invitation_token: String, invitation_created_at: (DateTime or Time), invitation_sent_at: (DateTime or Time), invitation_accepted_at: (DateTime or Time), invitation_limit: Integer, invited_by_id: Integer, invited_by_type: String, invitations_count: Integer, terms_of_service_version: Integer, urm: (false or true), races: String, primary_contact_info_id: Integer })) -> self",(%any) -> self,"def initialize(row)
    @row = row
  end",""
[s]UserHelpers,generate_username,"(([ respond_to?: (:connection) -> { { [s]UserHelpers#generate_username arg: queryable }#respond_to? ret: ret } ] and [ where: ({ username: String }) -> { { [s]UserHelpers#generate_username arg: queryable }#where ret: ret } ]), String) -> String","(%any, String) -> String","def self.generate_username(queryable, name)
    prefix = name.downcase.
      gsub(/[^#{USERNAME_ALLOWED_CHARACTERS.source}]+/, ' ')[0..USERNAME_MAX_LENGTH - 5].
      squish.
      tr(' ', '_')

    if prefix.empty? || prefix == ''
      prefix = 'coder' + rand(100000..999999).to_s
    end
    prefix = ""coder_#{prefix}"" if prefix.length < 5

    return prefix if queryable.where(username: prefix).limit(1).empty?

    # Throw random darts of increasing length (3 to 7 digits) to find an unused suffix.
    (2..6).each do |exponent|
      min_index = 10**exponent
      max_index = 10**(exponent + 1) - 1
      2.times do |_i|
        suffix = Random.rand(min_index..max_index)
        # Truncate generated username to max allowed length.
        username = ""#{prefix}#{suffix}""[0..USERNAME_MAX_LENGTH - 1]
        if queryable.where(username: username).limit(1).empty?
          return username
        end
      end
    end

    # Fallback to a range-scan query to find an available gap in the integer sequence.

    # Use CAST() and SUBSTRING() to parse the suffix as an integer.
    cast = lambda {|t| ""CAST(SUBSTRING(#{t}, #{prefix.length + 1}) as unsigned)""}

    query = <<SQL
SELECT #{cast.call('username')} + 1
  FROM users u
  WHERE username LIKE ""#{prefix}%""
    AND username RLIKE ""^#{prefix}[0-9]+$""
    AND NOT EXISTS (
      SELECT 1
      FROM users u2
      WHERE u2.username = CONCAT(""#{prefix}"", #{cast.call('u.username')} + 1)
    )
  LIMIT 1;
SQL
    # Execute raw query using either ActiveRecord or Sequel object.
    # MKCHANGE
    next_id = queryable.respond_to?(:connection) ?
      RDL.type_cast(queryable, ""ActiveRecord::ConnectionHandling"").connection.execute(query).first.first :
      RDL.type_cast(queryable, ""Sequel::Dataset"").db.fetch(query).first.values.first
    username = ""#{prefix}#{next_id}""
    raise ""generate_username overflow: #{username}"" if username.length > USERNAME_MAX_LENGTH
    username
  end",""
DashboardSection,member?,(Integer) -> (false or true),(Integer) -> (false or true),"def member?(user_id)
    return teacher?(user_id) || student?(user_id)
  end",""
[s]DashboardSection,assignable_info,"({ [s]DashboardSection#assignable_info arg: hidden }, { [s]DashboardSection#assignable_info arg: course_or_script }) -> { [s]DashboardSection#assignable_info ret: ret }","((false or true), { name: String, hidden: (false or true), id: Integer }) -> { id: Integer, name: String, category: String, script_name: String, position: Integer, category_priority: Integer }","def self.assignable_info(hidden, course_or_script) ## MKCHANGE: changed argument order
    info = ScriptConstants.assignable_info(course_or_script)
    info[:name] = I18n.t(""#{info[:name]}_name"", default: info[:name])
    info[:name] += "" *"" if hidden

    info[:category] = I18n.t(""#{info[:category]}_category_name"", default: info[:category])

    info
  end","# @typedef AssignableInfo Hash
# @option [Number] :id
# @option [String] :name,
# TODO: This is really course_or_script_name (or perhaps something like resource_name),
# but is currently used in a bunch of places in the client, so I don't want
# to change it just yet
# @option [String] :script_name
# @option [String] :category
# @option [Number] :position
# @option [Number] :category_priority
# Get the info for our script/course, and translate strings if needed.
# @param course_or_script [Course|Script] A row object from either our courses
#   or scripts dashboard db tables.
# @param hidden [Boolean] True if the passed in item is hidden
# @return AssignableInfo
"
Object,get_sharing_disabled_from_properties,(String) -> (false or true),(String) -> (false or true),"def get_sharing_disabled_from_properties(properties)
  return false unless properties
  parsed_properties = JSON.parse(properties)
  !!parsed_properties[""sharing_disabled""]
end",""
Object,storage_encrypt_channel_id,"(Integer, Integer) -> String","(Integer, Integer) -> String","def storage_encrypt_channel_id(storage_id, channel_id)
  storage_id = storage_id.to_i
  raise ArgumentError, ""`storage_id` must be an integer > 0"" unless storage_id > 0
  channel_id = channel_id.to_i
  raise ArgumentError, ""`channel_id` must be an integer > 0"" unless channel_id > 0
  Base64.urlsafe_encode64(storage_encrypt(""#{storage_id}:#{channel_id}"")).tr('=', '')
end",""
Object,storage_decrypt_channel_id,"(String) -> [{ Object#storage_decrypt_channel_id tuple_element: tuple_element_0 }, { Object#storage_decrypt_channel_id tuple_element: tuple_element_0 }]","(Integer) -> [Integer, Integer]","def storage_decrypt_channel_id(encrypted)
  raise ArgumentError, ""`encrypted` must be a string"" unless encrypted.is_a? String
  # pad to a multiple of 4 characters to make a valid base64 string.
  encrypted += '=' * ((4 - encrypted.length % 4) % 4)
  storage_id, channel_id = storage_decrypt(Base64.urlsafe_decode64(encrypted)).split(':').map(&:to_i)
  raise ArgumentError, ""`storage_id` must be an integer > 0"" unless storage_id > 0
  raise ArgumentError, ""`channel_id` must be an integer > 0"" unless channel_id > 0
  [storage_id, channel_id]
end","# This method can throw the following errors:
# ArgumentError if encrypted is incorrectly formatted/padded for base64; or
# OpenSSL::Cipher::CipherError if the base64-decoded value is not properly
# encrypted or was encrypted using a different key (e.g. on localhost vs prod).
"
[s]StorageApps,get_published_project_data,"({ [s]StorageApps#get_published_project_data arg: channel_id }, { value: String, project_type: { { [s]StorageApps#get_published_project_data arg: project }#[] ret: ret }, published_at: { { [s]StorageApps#get_published_project_data arg: project }#[] ret: ret } }) -> { channel: { [s]StorageApps#get_published_project_data arg: channel_id }, name: Object, thumbnailUrl: { [s]StorageApps#make_thumbnail_url_cacheable ret: ret }, type: { { [s]StorageApps#get_published_project_data arg: project }#[] ret: ret }, publishedAt: { { [s]StorageApps#get_published_project_data arg: project }#[] ret: ret } }","(Integer, { id: Integer, storage_id: Integer, value: String, updated_at: (DateTime or Time), updated_ip: String, state: String, created_at: (DateTime or Time), abuse_score: Integer, project_type: String, published_at: (DateTime or Time), standalone: (false or true), remix_parent_id: Integer }) -> { channel: Integer, name: String, thumbnailUrl: String, type: String, publishedAt: DateTime }","def self.get_published_project_data(channel_id, project) ## MKCHANGE: changed arg positions
    project_value = JSON.parse(project[:value])
    {
      channel: channel_id,
      name: project_value['name'],
      thumbnailUrl: StorageApps.make_thumbnail_url_cacheable(project_value['thumbnailUrl']),
      # Note that we are using the new :project_type field rather than extracting
      # it from :value. :project_type might not be present in unpublished projects.
      type: project[:project_type],
      publishedAt: project[:published_at],
    }
  end","# extracts published project data from a project (aka storage_apps table row).
"
[s]UserHelpers,initial,(String) -> String,(String) -> String,"def self.initial(name)
    return nil if name.blank?
    return name.strip[0].upcase
  end","# Upcase and return the first non-whitespace character of the user's name.
"
[s]UserHelpers,age_range_from_birthday,({ [s]UserHelpers#age_range_from_birthday arg: birthday }) -> nil,(DateTime) -> String,"def self.age_range_from_birthday(birthday)
    age = age_from_birthday(birthday)
    age_cutoff = AGE_CUTOFFS.find {|cutoff| cutoff <= age}
    age_cutoff ? ""#{age_cutoff}+"" : nil
  end","# Return the highest age range for the given birthday, e.g.
# 18+, 13+, 8+ or 4+
"
Object,user_storage_ids_table,"() -> Table<{ id: Integer, user_id: Integer, __selected: nil, __last_joined: :user_storage_ids, __all_joined: :user_storage_ids, __orm: false }>",() -> ``Sequel::Mysql2::Database.gen_output_type(RDL::Type::SingletonType.new(:user_storage_ids))``,"def user_storage_ids_table
  PEGASUS_DB[:user_storage_ids]
end",""
